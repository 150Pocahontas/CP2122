\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{palatino}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{cp2122t}
\usepackage{subcaption}
\usepackage{trees}
\usepackage{adjustbox}
\usepackage{color}
\definecolor{red}{RGB}{255,  0,  0}
\definecolor{blue}{RGB}{0,0,255}
\def\red{\color{red}}
\def\blue{\color{blue}}
%================= local x=====================================================%
\def\getGif#1{\includegraphics[width=0.3\textwidth]{cp2122t_media/#1.png}}
\let\uk=\emph
\def\aspas#1{``#1"}
%================= lhs2tex=====================================================%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\def\ana#1{\mathopen{[\!(}#1\mathclose{)\!]}}
%%format (bin (n) (k)) = "\Big(\vcenter{\xymatrix@R=1pt{" n "\\" k "}}\Big)"
\newlabel{eq:fokkinga}{{3.93}{110}{The mutual-recursion law}{section.3.17}{}}
\def\plus{\mathbin{\dagger}}

%---------------------------------------------------------------------------

\title{
          Cálculo de Programas
\\
          Trabalho Prático
\\
          LEI+MiEI --- 2021/22
}

\author{
          \dium
\\
          Universidade do Minho
}


\date\mydate

\makeindex
\newcommand{\rn}[1]{\textcolor{red}{#1}}
\begin{document}

\maketitle

\begin{center}\large
\begin{tabular}{ll}
\textbf{Grupo} nr. & 26
\\\hline
a89528 & Luís Magalhães
\\
a85829 & Meriam Khammassi
\\
a89578 & Patícia Pereira
\\
a88220 & Xavier Mota
\end{tabular}
\end{center}

\section{Preâmbulo}

\CP\ tem como objectivo principal ensinar
a progra\-mação de computadores como uma disciplina científica. Para isso
parte-se de um repertório de \emph{combinadores} que formam uma álgebra da
programação (conjunto de leis universais e seus corolários) e usam-se esses
combinadores para construir programas \emph{composicionalmente}, isto é,
agregando programas já existentes.

Na sequência pedagógica dos planos de estudo dos cursos que têm
esta disciplina, opta-se pela aplicação deste método à programação
em \Haskell\ (sem prejuízo da sua aplicação a outras linguagens
funcionais). Assim, o presente trabalho prático coloca os
alunos perante problemas concretos que deverão ser implementados em
\Haskell.  Há ainda um outro objectivo: o de ensinar a documentar
programas, a validá-los e a produzir textos técnico-científicos de
qualidade.

Antes de abodarem os problemas propostos no trabalho, os grupos devem ler
com atenção o anexo \ref{sec:documentacao} onde encontrarão as instruções
relativas ao sofware a instalar, etc.


\Problema

Num sistema de informação distribuído, uma lista não vazia de transações
é vista como um \textit\blockchain\ sempre que possui um valor de \textit{hash}
que é dado pela raiz de uma \MerkleTree\ que lhe está associada. Isto significa
que cada \textit\blockchain\ está estruturado numa \MerkleTree.
Mas, o que é uma \MerkleTree?

Uma \MerkleTree\ é uma \FTree\ com as seguintes propriedades:
%
\begin{eqnarray}
\fbox{
\begin{minipage}{.85\textwidth}
\begin{enumerate}
\item as folhas são pares (\ensuremath{\Varid{hash}}, transação) ou simplesmente o \ensuremath{\Varid{hash}} de uma transação;
\item os nodos são \ensuremath{\Varid{hashes}} que correspondem à concatenação dos \ensuremath{\Varid{hashes}} dos filhos;
\item o \ensuremath{\Varid{hash}} que se encontra na raiz da árvore é designado \ensuremath{\Conid{Merkle}\;\Conid{Root}}; como se disse acima, corresponde ao valor de \ensuremath{\Varid{hash}} de todo o bloco de transações.
\end{enumerate}
\end{minipage}
}&&
     \label{eq:MTree_props}
\end{eqnarray}


\begin{figure}
\fbox{
\begin{minipage}{\textwidth}\em
\begin{itemize}
\item Se a lista for singular, calcular o \ensuremath{\Varid{hash}} da transação.

\item Caso contrário,
\begin{enumerate}
\item Mapear a lista com a função \ensuremath{\Varid{hash}}.

\item Se o comprimento da lista for ímpar, concatenar a lista com o seu último valor (que fica duplicado). Caso contrário, a lista não sofre alterações.

\item Agrupar a lista em pares.

\item Concatenar os \ensuremath{\Varid{hashes}} do par produzindo uma lista de (sub-)árvores nas quais a cabeça terá a respetiva concatenação.

\item Se a lista de (sub-)árvores não for singular, voltar ao passo 2 com a lista das cabeças como argumento, preservando a lista de (sub-)árvores. Se a lista for singular, chegamos à \ensuremath{\Conid{Merkle}\;\Conid{Root}}. Contudo, falta compor a \ensuremath{\Conid{Merkle}\;\Conid{Tree}} final. Para tal, tendo como resultado uma lista de listas de (sub-)árvores agrupada pelos níveis da árvore final, é necessário encaixar sucessivamente os tais níveis formando a \ensuremath{\Conid{Merkle}\;\Conid{Tree}} completa.
\end{enumerate}
\end{itemize}
\end{minipage}
}\caption{Algoritmo clássico de construção de uma \MerkleTree\ \cite{Se19} \label{fig:algMTree}.}
\end{figure}

Assumindo uma lista não vazia de transações, o algoritmo clássico de construção
de uma \ensuremath{\Conid{Merkle}\;\Conid{Tree}} é o que está dado na Figura \ref{fig:algMTree}. Contudo,
este algoritmo (que se pode mostrar ser um hilomorfismo de listas não vazias)
é demasiadamente complexo. Uma forma bem mais simples de produzir uma \ensuremath{\Conid{Merkle}\;\Conid{Tree}} é através de um hilomorfismo de \LTree s. Começa-se por, a partir da
lista de transações, construir uma \LTree\ cujas folhas são as transações:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{list2LTree}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to {\LTree}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Depois, o objetivo é etiquetar essa árvore com os \ensuremath{\Varid{hashes}},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{lTree2MTree}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow {\LTree}\;\Varid{a}\to \underbrace{{\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{a})}_{\Conid{Merkle}\;\Varid{tree}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
formando uma \MerkleTree\ que satisfaça os três requisitos em (\ref{eq:MTree_props}).
Em suma, a construção de um \blockchain\ é um hilomorfismo de \LTree s
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{computeMerkleTree}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to {\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{computeMerkleTree}\mathrel{=}\Varid{lTree2MTree}\comp \Varid{list2LTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{enumerate}
\item     Comece por definir o gene do anamorfismo que constrói \LTree s a partir de listas não vazias:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{list2LTree}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to {\LTree}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{list2LTree}\mathrel{=}\mathopen{[\!(}\Varid{g\char95 list2LTree}\mathclose{)\!]}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\textbf{NB}: para garantir que \ensuremath{\Varid{list2LTree}} não aceita listas vazias deverá
usar em \ensuremath{\Varid{g\char95 list2LTree}} o inverso \ensuremath{\Varid{outNEList}} do isomorfismo
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inNEList}\mathrel{=}\alt{\Varid{singl}}{\Varid{cons}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\item

Assumindo as seguintes funções \ensuremath{\Varid{hash}} e \ensuremath{\Varid{concHash}}:\footnote{Para invocar a função \ensuremath{\Varid{hash}}, escreva \ensuremath{\Varid{\Conid{Main}.hash}}.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{hash}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow \Varid{a}\to \mathbb{Z}{}\<[E]%
\\
\>[B]{}\Varid{hash}\mathrel{=}\Varid{toInteger}\comp (\Varid{\Conid{Data}.\Conid{Hashable}.hash}){}\<[E]%
\\
\>[B]{}\Varid{concHash}\mathbin{::}(\mathbb{Z},\mathbb{Z})\to \mathbb{Z}{}\<[E]%
\\
\>[B]{}\Varid{concHash}\mathrel{=}\Varid{add}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\noindent defina o gene do catamorfismo que consome a \LTree\ e produz
a correspondente \MerkleTree\ etiquetada com todos os \ensuremath{\Varid{hashes}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{lTree2MTree}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow {\LTree}\;\Varid{a}\to {\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{lTree2MTree}\mathrel{=}\llparenthesis\, \Varid{g\char95 lTree2MTree}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\item Defina \ensuremath{\Varid{g\char95 mroot}} por forma a
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mroot}\mathbin{::}\Conid{Hashable}\;\Varid{b}\Rightarrow [\mskip1.5mu \Varid{b}\mskip1.5mu]\to \mathbb{Z}{}\<[E]%
\\
\>[B]{}\Varid{mroot}\mathrel{=}\llparenthesis\, \Varid{g\char95 mroot}\,\rrparenthesis\comp \Varid{computeMerkleTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
nos dar a Merkle \emph{root} de um qualquer bloco \ensuremath{[\mskip1.5mu \Varid{b}\mskip1.5mu]} de transações.

\item

Calcule \ensuremath{\Varid{mroot}\;\Varid{trs}} da sequência de transações \ensuremath{\Varid{trs}} da no anexo e verifique que, sempre que se modifica (e.g.\ fraudulentamente) uma transação passada em \ensuremath{\Varid{trs}}, \ensuremath{\Varid{mroot}\;\Varid{trs}} altera-se necessariamente. Porquê? (Esse é exactamente o princípio de funcionamento da tecnologia \blockchain.)
\end{enumerate}

\begin{quote}\small
\vskip 1em \hrule \vskip 1em
\textbf{Valorização} (não obrigatória): implemente o algoritmo clássico de
construção de \MerkleTree s
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{classicMerkleTree}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to {\FTree}\;\mathbb{Z}\;\mathbb{Z}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
sob a forma de um hilomorfismo de listas não vazias.
Para isso deverá definir esse combinador primeiro, da forma habitual:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{hyloNEList}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataNEList}\;\Varid{h}\comp \Varid{anaNEList}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
etc.
Depois passe à definição do gene \ensuremath{\Varid{g\char95 pairsList}} do anamorfismo de listas
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pairsList}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},\Varid{a})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pairsList}\mathrel{=}\anaList{\Varid{g\char95 pairsList}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que agrupa a lista argumento por pares, duplicando o último valor caso seja necessário. Para tal, poderá usar a função (já definida)
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{getEvenBlock}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que, dada uma lista, se o seu comprimento for ímpar, duplica o último valor.

Por fim, defina os genes \ensuremath{\Varid{divide}} e \ensuremath{\Varid{conquer}} dos respetivos anamorfismo e catamorfimo por forma a
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{classicMerkleTree}\mathrel{=}(\Varid{hyloNEList}\;\Varid{conquer}\;\Varid{divide})\comp (\map \;\Varid{\Conid{Main}.hash}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Para facilitar a definição do \ensuremath{\Varid{conquer}}, terá apenas de definir o gene \ensuremath{\Varid{g\char95 mergeMerkleTree}} do catamorfismo de ordem superior
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mergeMerkleTree}\mathbin{::}{\FTree}\;\Varid{a}\;\Varid{p}\to [\mskip1.5mu {\FTree}\;\Varid{a}\;\Varid{c}\mskip1.5mu]\to {\FTree}\;\Varid{a}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{mergeMerkleTree}\mathrel{=}\llparenthesis\, \Varid{g\char95 mergeMerkleTree}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que compõe a \FTree\ (à cabeça) com a lista de \FTree s (como filhos), fazendo um ``merge'' dos valores intermédios. Veja o seguinte exemplo de aplicação da função \ensuremath{\Varid{mergeMerkleTree}}:
\begin{tabbing}\ttfamily
~~\char62{}~l~\char61{}~\char91{}Comp~3~\char40{}Unit~1\char44{}~Unit~2\char41{}\char44{}~Comp~7~\char40{}Unit~3\char44{}~Unit~4\char41{}\char93{}\\
\ttfamily ~~\char62{}\\
\ttfamily ~~\char62{}~m~\char61{}~Comp~10~\char40{}Unit~3\char44{}~Unit~7\char41{}\\
\ttfamily ~~\char62{}\\
\ttfamily ~~\char62{}~mergeMerkleTree~m~l\\
\ttfamily ~Comp~10~\char40{}Comp~3~\char40{}Unit~1\char44{}Unit~2\char41{}\char44{}Comp~7~\char40{}Unit~3\char44{}Unit~4\char41{}\char41{}
\end{tabbing}

\textbf{NB}: o \textit{classicMerkleTree} retorna uma Merkle Tree cujas folhas são apenas o \ensuremath{\Varid{hash}} da transação e não o par (\ensuremath{\Varid{hash}}, transação).
\vskip 1em \hrule \vskip 1em
\end{quote}

\Problema

Se se digitar \wc{\ensuremath{\Varid{man}\;\Varid{wc}}} na shell do Unix (Linux) obtém-se:
\begin{quote}\small
\begin{tabbing}\ttfamily
~NAME\\
\ttfamily ~~~~~~wc~\char45{}\char45{}~word\char44{}~line\char44{}~character\char44{}~and~byte~count\\
\ttfamily ~\\
\ttfamily ~SYNOPSIS\\
\ttfamily ~~~~~~wc~\char91{}\char45{}clmw\char93{}~\char91{}file~\char46{}\char46{}\char46{}\char93{}\\
\ttfamily ~\\
\ttfamily ~DESCRIPTION\\
\ttfamily ~~~~~The~wc~utility~displays~the~number~of~lines\char44{}~words\char44{}~and~bytes~contained~in\\
\ttfamily ~~~~~each~input~file\char44{}~~or~standard~input~\char40{}if~no~file~is~specified\char41{}~to~the~stan\char45{}\\
\ttfamily ~~~~~dard~~output\char46{}~~A~line~is~defined~as~~a~string~of~characters~delimited~by~a\\
\ttfamily ~~~~~\char60{}newline\char62{}~character\char46{}~~Characters~beyond~the~final~\char60{}newline\char62{}~character~will\\
\ttfamily ~~~~~not~be~included~in~the~line~count\char46{}\\
\ttfamily ~~~~~\char40{}\char46{}\char46{}\char46{}\char41{}\\
\ttfamily ~~~~~The~following~options~are~available\char58{}\\
\ttfamily ~~~~~\char40{}\char46{}\char46{}\char46{}\char41{}\\
\ttfamily ~~~~~~~~~\char45{}w~~~The~number~of~words~in~each~input~file~is~written~to~the~standard\\
\ttfamily ~~~~~~~~~~~~~~output\char46{}\\
\ttfamily ~~~~~\char40{}\char46{}\char46{}\char46{}\char41{}
\end{tabbing}
\end{quote}
Se olharmos para o código da função que, em C, implementa esta funcionalidade
\cite{KR78} e nos focarmos apenas na parte que implementa a opção \text{\ttfamily \char45{}w},
verificamos que a poderíamos escrever, em Haskell, da forma seguinte:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{wc\char95 w}\mathbin{::}[\mskip1.5mu \Conid{Char}\mskip1.5mu]\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{wc\char95 w}\;[\mskip1.5mu \mskip1.5mu]{}\<[12]%
\>[12]{}\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}\Varid{wc\char95 w}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\mathbf{if}\;\neg \;(\Varid{sep}\;\Varid{c})\mathrel{\wedge}\Varid{lookahead\char95 sep}\;\Varid{l}\;\mathbf{then}\;\Varid{wc\char95 w}\;\Varid{l}\mathbin{+}\mathrm{1}\;\mathbf{else}\;\Varid{wc\char95 w}\;\Varid{l}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\mathbf{where}{}\<[E]%
\\
\>[8]{}\hsindent{3}{}\<[11]%
\>[11]{}\Varid{sep}\;\Varid{c}\mathrel{=}(\Varid{c}\equiv \text{\ttfamily '~'}\mathrel{\vee}\Varid{c}\equiv \text{\ttfamily '\char92 n'}\mathrel{\vee}\Varid{c}\equiv \text{\ttfamily '\char92 t'}){}\<[E]%
\\
\>[8]{}\hsindent{3}{}\<[11]%
\>[11]{}\Varid{lookahead\char95 sep}\;[\mskip1.5mu \mskip1.5mu]{}\<[31]%
\>[31]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[8]{}\hsindent{3}{}\<[11]%
\>[11]{}\Varid{lookahead\char95 sep}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}\Varid{sep}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Por aplicação da lei de recursividade mútua
\begin{eqnarray}
\ensuremath{\begin{lcbr}\Varid{f}\comp \mathsf{in}\mathrel{=}\Varid{h}\comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\\\Varid{g}\comp \mathsf{in}\mathrel{=}\Varid{k}\comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\end{lcbr}}
     & \equiv &
     \ensuremath{\conj{\Varid{f}}{\Varid{g}}\mathrel{=}\cata{\conj{\Varid{h}}{\Varid{k}}}}
\end{eqnarray}
às funções \ensuremath{\Varid{wc\char95 w}} e \ensuremath{\Varid{lookahead\char95 sep}}, re-implemente a primeira segundo o
modelo \emph{\ensuremath{\Varid{worker}}/\ensuremath{\Varid{wrapper}}} onde \ensuremath{\Varid{worker}} deverá ser um catamorfismo
de listas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{wc\char95 w\char95 final}\mathbin{::}[\mskip1.5mu \Conid{Char}\mskip1.5mu]\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{wc\char95 w\char95 final}\mathrel{=}\Varid{wrapper}\comp \underbrace{\cataList{\alt{\Varid{g1}}{\Varid{g2}}}}_{\Varid{worker}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Apresente os cálculos que fez para chegar à versão \ensuremath{\Varid{wc\char95 w\char95 final}} de \ensuremath{\Varid{wc\char95 w}},
com indicação dos genes \ensuremath{\Varid{h}}, \ensuremath{\Varid{k}} e \ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{g1}}{\Varid{g2}}}.

\Problema

Neste problema pretende-se gerar o HTML de uma página de um jornal descrita
como uma agregação estruturada de blocos de texto ou imagens:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Unit}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Image}\;\Varid{a}\mid \Conid{Text}\;\Varid{b}\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
O tipo \ensuremath{\Conid{Sheet}} (=``página de jornal'')
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Sheet}\;\Varid{a}\;\Varid{b}\;\Varid{i}\mathrel{=}\Conid{Rect}\;(\Conid{Frame}\;\Varid{i})\;(\Conid{X}\;(\Conid{Unit}\;\Varid{a}\;\Varid{b})\;(\Conid{Mode}\;\Varid{i}))\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
é baseado num tipo indutivo $X$ que, dado em anexo (pág.~\pageref{sec:C}),
exprime a partição de um rectângulo (a página tipográfica) em vários subrectângulos
(as caixas tipográficas a encher com texto ou imagens),
segundo um processo de partição binária, na horizontal ou na vertical.
Para isso, o tipo
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Mode}\;\Varid{i}\mathrel{=}\Conid{Hr}\;\Varid{i}\mid \Conid{Hl}\;\Varid{i}\mid \Conid{Vt}\;\Varid{i}\mid \Conid{Vb}\;\Varid{i}\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
especifica quatro variantes de partição. O seu argumento deverá
ser um número de 0 a 1, indicando a fracção da altura (ou da largura) em que o
rectângulo é dividido, a saber:
\begin{itemize}
\item \texttt{Hr i} ---  partição horizontal, medindo $i$ a partir da direita
\item \texttt{Hl i} ---  partição horizontal, medindo $i$ a partir da esquerda
\item \texttt{Vt i} ---  partição vertical, medindo $i$ a partir do topo
\item \texttt{Vb i} ---  partição vertical, medindo $i$ a partir da base
\end{itemize}

Por exemplo, a partição dada na figura \ref{fig:1} corresponde à partição
de um rectângulo de acordo com a seguinte árvore de partições:
%
\begin{eqnarray*}
\mbox{
\tree{\ensuremath{\Conid{Hl}\;(\mathrm{0.41})}}
\subtree{\ensuremath{\Conid{Vt}\;(\mathrm{0.48})}}
\leaf{\ensuremath{\Varid{c}}}
\subtree{\ensuremath{\Conid{Vt}\;(\mathrm{0.36})}}
\leaf{\ensuremath{\Varid{d}}}
\leaf{\ensuremath{\Varid{e}}}
\endsubtree
\endsubtree
\subtree{\ensuremath{\Conid{Vb}\;(\mathrm{0.6})}}
\leaf{\ensuremath{\Varid{a}}}
\leaf{\ensuremath{\Varid{b}}}
\endsubtree
\endtree
}
\end{eqnarray*}

\begin{figure}
\begin{center}
\unitlength=.05mm
\special{em:linewidth 0.2pt}
\begin{picture}(780.00,960.00)
\put(0.00,0.00){\makebox(320,320)[cc]{$e$}}
\put(0.00,0.00){\line(1,0){320.00}}
\put(0.00,0.00){\line(0,1){320.00}}
\put(0.00,320.00){\line(1,0){320.00}}
\put(320.00,0.00){\line(0,1){320.00}}
\put(0.00,320.00){\makebox(320,180)[cc]{$d$}}
\put(0.00,320.00){\line(0,1){180.00}}
\put(0.00,500.00){\line(1,0){320.00}}
\put(320.00,320.00){\line(0,1){180.00}}
\put(0.00,500.00){\makebox(320,460)[cc]{$c$}}
\put(0.00,500.00){\line(0,1){460.00}}
\put(0.00,960.00){\line(1,0){320.00}}
\put(320.00,500.00){\line(0,1){460.00}}
\put(320.00,0.00){\makebox(460,580)[cc]{$ b$}}
\put(320.00,0.00){\line(1,0){460.00}}
\put(320.00,0.00){\line(0,1){580.00}}
\put(320.00,580.00){\line(1,0){460.00}}
\put(780.00,0.00){\line(0,1){580.00}}
\put(320.00,580.00){\makebox(460,380)[cc]{$a $}}
\put(320.00,580.00){\line(0,1){380.00}}
\put(320.00,960.00){\line(1,0){460.00}}
\put(780.00,580.00){\line(0,1){380.00}}
\end{picture}
\end{center}
\caption{Layout de página de jornal.\label{fig:1}}
\end{figure}

As caixas delineadas por uma partição (como a dada acima) correspondem a
folhas da árvore de partição e podem conter texto ou imagens. É o que
se verifica no objecto \ensuremath{\Varid{example}} da secção \ref{sec:test_data}
que, processado por \ensuremath{\Varid{sheet2html}} (secção \ref{sec:html})
vem a produzir o ficheiro \texttt{jornal.html}.

\paragraph{O que se pretende}
O código em \Haskell\ fornecido no anexo \ref{sec:codigo}
como ``kit'' para arranque deste trabalho não está estruturado
em termos dos combinadores \emph{cata-ana-hylo} estudados nesta disciplina.
%
O que se pretende é, então:
\begin{enumerate}
\item     A construção de uma biblioteca ``pointfree''
     \footnote{%
          A desenvolver de forma análoga a outras bibliotecas que
          conhece (\eg\ \LTree, etc).
}
     com base na qual o processamento (``pointwise'') já disponível
     possa ser redefinido.
\item     A evolução da biblioteca anterior para uma outra que permita
     partições $n$-árias (para \emph{qualquer} $n$ finito)
     e não apenas binárias. \footnote{
          Repare que é a falta desta capacidade expressiva
          que origina, no ``kit'' actual, a definição das funções
          auxiliares  da secção \ref{sec:faux}, por exemplo.
     }
\end{enumerate}

\Problema

Este exercício tem como objectivo determinar todos os caminhos
possíveis de um ponto \emph{A} para um ponto \emph{B}. Para tal,
iremos utilizar técnicas de
\href{https://en.wikipedia.org/wiki/Brute-force_search}{\emph{brute
force}} e
\href{https://en.wikipedia.org/wiki/Backtracking}{\emph{backtracking}}, que podem
ser codificadas no \listM{mónade das listas} (estudado na \href{https://haslab.github.io/CP/Material/}{aulas}). Comece por implementar a seguinte função auxiliar:

\begin{enumerate}
\item \ensuremath{\Varid{pairL}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},\Varid{a})\mskip1.5mu]} que dada uma lista \ensuremath{\Varid{l}} de tamanho
maior que \ensuremath{\mathrm{1}} produz uma nova lista cujos elementos são os pares \ensuremath{(\Varid{x},\Varid{y})} de
elementos de \ensuremath{\Varid{l}} tal que \ensuremath{\Varid{x}} precede imediatamente \ensuremath{\Varid{y}}. Por exemplo:
\begin{quote}
     \ensuremath{\Varid{pairL}\;[\mskip1.5mu \mathrm{1},\mathrm{2}\mskip1.5mu]\equiv [\mskip1.5mu (\mathrm{1},\mathrm{2})\mskip1.5mu]},
\\
     \ensuremath{\Varid{pairL}\;[\mskip1.5mu \mathrm{1},\mathrm{2},\mathrm{3}\mskip1.5mu]\equiv [\mskip1.5mu (\mathrm{1},\mathrm{2}),(\mathrm{2},\mathrm{3})\mskip1.5mu]} e
\\
     \ensuremath{\Varid{pairL}\;[\mskip1.5mu \mathrm{1},\mathrm{2},\mathrm{3},\mathrm{4}\mskip1.5mu]\equiv [\mskip1.5mu (\mathrm{1},\mathrm{2}),(\mathrm{2},\mathrm{3}),(\mathrm{3},\mathrm{4})\mskip1.5mu]}
\end{quote}
Para o caso em que \ensuremath{\Varid{l}\mathrel{=}[\mskip1.5mu \Varid{x}\mskip1.5mu]}, i.e. o tamanho de \ensuremath{\Varid{l}} é \ensuremath{\mathrm{1}}, assuma que \ensuremath{\Varid{pairL}\;[\mskip1.5mu \Varid{x}\mskip1.5mu]\equiv [\mskip1.5mu (\Varid{x},\Varid{x})\mskip1.5mu]}. Implemente esta função como um \emph{anamorfismo de listas}, atentando na sua propriedade:

\begin{itemize}\em
\item      Para todas as listas \ensuremath{\Varid{l}} de tamanho maior que 1,
a lista \ensuremath{\map \;\p1\;(\Varid{pairL}\;\Varid{l})} é a lista original \ensuremath{\Varid{l}} a menos do último elemento.
Analogamente, a lista \ensuremath{\map \;\p2\;(\Varid{pairL}\;\Varid{l})}  é a lista original \ensuremath{\Varid{l}} a menos do primeiro elemento.
\end{itemize}
\end{enumerate}


De seguida necessitamos de uma estrutura de dados representativa da noção de espaço,
para que seja possível formular a noção de \emph{caminho} de um ponto \ensuremath{\Conid{A}} para um ponto \ensuremath{\Conid{B}},
por exemplo, num papel quadriculado. No nosso caso vamos ter:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Cell}\mathrel{=}\Conid{Free}\mid \Conid{Blocked}\mid {}\<[31]%
\>[31]{}\Conid{Lft}\mid \Conid{Rght}\mid \Conid{Up}\mid \Conid{Down}\;\mathbf{deriving}\;(\Conid{Eq},\Conid{Show}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Map}\mathrel{=}[\mskip1.5mu [\mskip1.5mu \Conid{Cell}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O terreno onde iremos navegar é codificado então numa \emph{matriz} de
células.  Os valores \emph{Free} and \emph{Blocked} denotam uma célula
como livre ou bloqueada, respectivamente (a navegação entre dois
pontos terá que ser realizada \emph{exclusivamente} através de células
livres). Ao correr, por exemplo, \ensuremath{\Varid{putStr}\mathbin{\$}\Varid{showM}\mathbin{\$}map_1 } no interpretador  irá obter a seguinte apresentação de um mapa:
\begin{tabbing}\ttfamily
~~\char95{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char95{}~~X~~\char95{}\\
\ttfamily ~~\char95{}~~X~~\char95{}
\end{tabbing}
Para facilitar o teste das implementações pedidas abaixo, disponibilizamos no anexo \ref{sec:codigo}
a função \ensuremath{\Varid{testWithRndMap}}. Por exemplo, ao correr
\ensuremath{\Varid{testWithRndMap}} obtivemos o seguinte mapa aleatoriamente:
\begin{tabbing}\ttfamily
~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~X\\
\ttfamily ~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X\\
\ttfamily ~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}~~X~~\char95{}\\
\ttfamily ~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char95{}~~X~~X~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}\\
\ttfamily ~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~X~~\char95{}\\
\ttfamily ~~\char95{}~~\char95{}~~X~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~\char95{}~~X\\
\ttfamily ~Map~of~dimension~10x10\char46{}
\end{tabbing}

De seguida, os valores \ensuremath{\Conid{Lft}}, \ensuremath{\Conid{Rght}},
\ensuremath{\Conid{Up}} e \ensuremath{\Conid{Down}} em \ensuremath{\Conid{Cell}} denotam o facto de uma célula ter sido alcançada
através da célula à esquerda, direita, de cima, ou de baixo, respectivamente.
Tais valores irão ser usados na representação de caminhos num mapa.

\begin{enumerate}
\setcounter{enumi}{1}
\item

Implemente agora a função \ensuremath{\Varid{markMap}\mathbin{::}[\mskip1.5mu \Conid{Pos}\mskip1.5mu]\to \Conid{Map}\to \Conid{Map}},
que dada uma lista de posições (representante de um \emph{caminho} de um ponto \emph{A} para
um ponto \emph{B}) e um mapa retorna um novo mapa com o caminho lá marcado.
Por exemplo, ao correr no interpretador,
\begin{center}
\ensuremath{\Varid{putStr}\mathbin{\$}\Varid{showM}\mathbin{\$}\Varid{markMap}\;[\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{0},\mathrm{2}),(\mathrm{1},\mathrm{2})\mskip1.5mu]\;map_1 }
\end{center}
deverá obter a seguinte apresentação de um mapa e respectivo caminho:
\begin{tabbing}\ttfamily
~~\char62{}~~\char95{}~~\char95{}\\
\ttfamily ~~\char94{}~~X~~\char95{}\\
\ttfamily ~~\char94{}~~X~~\char95{}
\end{tabbing}
representante do caso em que subimos duas vezes no mapa e depois viramos à direita.
Para implementar a função \ensuremath{\Varid{markMap}} deverá recorrer à função \ensuremath{\Varid{toCell}} (disponibilizada
no anexo \ref{sec:codigo}) e a uma função auxiliar com o tipo \ensuremath{[\mskip1.5mu (\Conid{Pos},\Conid{Pos})\mskip1.5mu]\to \Conid{Map}\to \Conid{Map}} definida como
um \emph{catamorfismo de listas}. Tal como anteriormente, anote as propriedades seguintes sobre
\ensuremath{\Varid{markMap}}:\footnote{Ao implementar a função \ensuremath{\Varid{markMap}}, estude também
a função \ensuremath{\Varid{subst}} (disponibilizada no anexo \ref{sec:codigo}) pois as duas funções tem
algumas semelhanças.}
\begin{itemize}\em
\item      Para qualquer lista \ensuremath{\Varid{l}} a função \ensuremath{\Varid{markMap}\;\Varid{l}} é idempotente.
\item      Todas as posições presentes na lista dada como argumento
irão fazer com que as células correspondentes no mapa deixem de ser \ensuremath{\Conid{Free}}.
\end{itemize}
\end{enumerate}

Finalmente há que implementar a função \ensuremath{\Varid{scout}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to \Conid{Pos}\to \Conid{Int}\to [\mskip1.5mu [\mskip1.5mu \Conid{Pos}\mskip1.5mu]\mskip1.5mu]},
que dado um mapa \ensuremath{\Varid{m}}, uma posição inicial \ensuremath{\Varid{s}}, uma posição alvo \ensuremath{\Varid{t}}, e um número
inteiro \ensuremath{\Varid{n}}, retorna uma lista de caminhos que começam em \ensuremath{\Varid{s}} e que têm tamanho máximo
\ensuremath{\Varid{n}\mathbin{+}\mathrm{1}}. Nenhum destes caminhos pode conter \ensuremath{\Varid{t}} como elemento que não seja o último na lista (i.e. um caminho deve terminar logo que se alcança a posição \ensuremath{\Varid{t}}). Para além disso,
não é permitido voltar a posições previamente visitadas e se ao alcançar uma posição
diferente de \ensuremath{\Varid{t}} é impossivel sair dela então todo o caminho que levou a esta
posição deve ser removido (\emph{backtracking}). Por exemplo: \\

\noindent
\ensuremath{\Varid{scout}\;map_1 \;(\mathrm{0},\mathrm{0})\;(\mathrm{2},\mathrm{0})\;\mathrm{0}\equiv [\mskip1.5mu [\mskip1.5mu (\mathrm{0},\mathrm{0})\mskip1.5mu]\mskip1.5mu]}

\noindent
\ensuremath{\Varid{scout}\;map_1 \;(\mathrm{0},\mathrm{0})\;(\mathrm{2},\mathrm{0})\;\mathrm{1}\equiv [\mskip1.5mu [\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1})\mskip1.5mu]\mskip1.5mu]}

\noindent
\ensuremath{\Varid{scout}\;map_1 \;(\mathrm{0},\mathrm{0})\;(\mathrm{2},\mathrm{0})\;\mathrm{4}\equiv [\mskip1.5mu [\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{0},\mathrm{2}),(\mathrm{1},\mathrm{2}),(\mathrm{2},\mathrm{2})\mskip1.5mu]\mskip1.5mu]}

\noindent
\ensuremath{\Varid{scout}\;map_2 \;(\mathrm{0},\mathrm{0})\;(\mathrm{2},\mathrm{2})\;\mathrm{2}\equiv [\mskip1.5mu [\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{1},\mathrm{1})\mskip1.5mu],[\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{0},\mathrm{2})\mskip1.5mu]\mskip1.5mu]}

\noindent
\ensuremath{\Varid{scout}\;map_2 \;(\mathrm{0},\mathrm{0})\;(\mathrm{2},\mathrm{2})\;\mathrm{4}\equiv [\mskip1.5mu [\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{1},\mathrm{1}),(\mathrm{2},\mathrm{1}),(\mathrm{2},\mathrm{2})\mskip1.5mu],[\mskip1.5mu (\mathrm{0},\mathrm{0}),(\mathrm{0},\mathrm{1}),(\mathrm{1},\mathrm{1}),(\mathrm{2},\mathrm{1}),(\mathrm{2},\mathrm{0})\mskip1.5mu]\mskip1.5mu]}

\begin{enumerate}
\setcounter{enumi}{2}
\item   Implemente a função
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{scout}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to \Conid{Pos}\to \Conid{Int}\to [\mskip1.5mu [\mskip1.5mu \Conid{Pos}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
recorrendo à função \ensuremath{\Varid{checkAround}} (disponibilizada no anexo \ref{sec:codigo}) e de tal forma a que
\ensuremath{\Varid{scout}\;\Varid{m}\;\Varid{s}\;\Varid{t}} seja um catamorfismos de naturais \emph{monádico}.
Anote a seguinte propriedade desta função:

\begin{itemize}\em
\item     \label{en:6a}
Quanto maior for o tamanho máximo permitido aos caminhos,  mais caminhos que alcançam a
posição alvo iremos encontrar.
\end{itemize}
\end{enumerate}

\newpage
\part*{Anexos}

\appendix

\section{Documentação para realizar o trabalho}
\label{sec:documentacao}
Para cumprir de forma integrada os objectivos Rdo trabalho vamos recorrer
a uma técnica de programa\-ção dita
``\litp{literária}'' \cite{Kn92}, cujo princípio base é o seguinte:
%
\begin{quote}\em Um programa e a sua documentação devem coincidir.
\end{quote}
%
Por outras palavras, o código fonte e a documentação de um
programa deverão estar no mesmo ficheiro.

O ficheiro \texttt{cp2122t.pdf} que está a ler é já um exemplo de
\litp{programação literária}: foi gerado a partir do texto fonte
\texttt{cp2122t.lhs}\footnote{O sufixo `lhs' quer dizer
\emph{\lhaskell{literate Haskell}}.} que encontrará no
\MaterialPedagogico\ desta disciplina descompactando o ficheiro
\texttt{cp2122t.zip} e executando:
\begin{Verbatim}[fontsize=\small]
    $ lhs2TeX cp2122t.lhs > cp2122t.tex
    $ pdflatex cp2122t
\end{Verbatim}
em que \href{https://hackage.haskell.org/package/lhs2tex}{\texttt\LhsToTeX} é
um pre-processador que faz ``pretty printing''
de código Haskell em \Latex\ e que deve desde já instalar executando
\begin{Verbatim}[fontsize=\small,commandchars=\\\{\}]
    $ cabal install lhs2tex --lib
    $ cabal install --ghc-option=-dynamic lhs2tex
\end{Verbatim}
\textbf{NB}: utilizadores do macOS poderão instalar o \ensuremath{\Varid{cabal}} com o seguinte comando:
\begin{Verbatim}[fontsize=\small,commandchars=\\\{\}]
    $ brew install cabal-install
\end{Verbatim}
Por outro lado, o mesmo ficheiro \texttt{cp2122t.lhs} é executável e contém
o ``kit'' básico, escrito em \Haskell, para realizar o trabalho. Basta executar
\begin{Verbatim}[fontsize=\small]
    $ ghci cp2122t.lhs
\end{Verbatim}

\noindent Abra o ficheiro \texttt{cp2122t.lhs} no seu editor de texto preferido
e verifique que assim é: todo o texto que se encontra dentro do ambiente
\begin{quote}\small\tt
\text{\ttfamily \char92{}begin\char123{}code\char125{}}
\\ ... \\
\text{\ttfamily \char92{}end\char123{}code\char125{}}
\end{quote}
é seleccionado pelo \GHCi\ para ser executado.

\subsection{Como realizar o trabalho}
Este trabalho teórico-prático deve ser realizado por grupos de 3 (ou 4) alunos.
Os detalhes da avaliação (datas para submissão do relatório e sua defesa
oral) são os que forem publicados na \cp{página da disciplina} na \emph{internet}.

Recomenda-se uma abordagem participativa dos membros do grupo
em todos os exercícios do trabalho, para assim
poderem responder a qualquer questão colocada na
\emph{defesa oral} do relatório.

Em que consiste, então, o \emph{relatório} a que se refere o parágrafo anterior?
É a edição do texto que está a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relatório deverá conter ainda a identificação dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relatório deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com \Bibtex) e o índice remissivo (com \Makeindex),
\begin{Verbatim}[fontsize=\small]
    $ bibtex cp2122t.aux
    $ makeindex cp2122t.idx
\end{Verbatim}
e recompilar o texto como acima se indicou. Dever-se-á ainda instalar o utilitário
\QuickCheck,
que ajuda a validar programas em \Haskell:
\begin{Verbatim}[fontsize=\small,commandchars=\\\{\}]
    $ cabal install QuickCheck --lib
\end{Verbatim}
Para testar uma propriedade \QuickCheck~\ensuremath{\Varid{prop}}, basta invocá-la com o comando:
\begin{tabbing}\ttfamily
~~~~~\char62{}~quickCheck~prop\\
\ttfamily ~~~~~\char43{}\char43{}\char43{}~OK\char44{}~passed~100~tests\char46{}
\end{tabbing}
Pode-se ainda controlar o número de casos de teste e sua complexidade,
como o seguinte exemplo mostra:\footnote{
Como já sabe, os testes normalmente não provam a ausência
de erros no código, apenas a sua presença (\href{https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD303.html}{cf. arquivo online}). Portanto não deve ver o facto
de o seu código passar nos testes abaixo como uma garantia que este está livre de erros.}
\begin{tabbing}\ttfamily
~~~~~\char62{}~quickCheckWith~stdArgs~\char123{}~maxSuccess~\char61{}~200\char44{}~maxSize~\char61{}~10~\char125{}~prop\\
\ttfamily ~~~~~\char43{}\char43{}\char43{}~OK\char44{}~passed~200~tests\char46{}
\end{tabbing}

Qualquer programador tem, na vida real, de ler e analisar (muito!) código
escrito por outros. No anexo \ref{sec:codigo} disponibiliza-se algum
código \Haskell\ relativo aos problemas que se seguem. Esse anexo deverá
ser consultado e analisado à medida que isso for necessário.

\paragraph{Stack}

O \stack{Stack} é um programa útil para criar, gerir e manter projetos em \Haskell.
Um projeto criado com o Stack possui uma estrutura de pastas muito específica:

\begin{itemize}
\item Os módulos auxiliares encontram-se na pasta \emph{src}.
\item O módulo principal encontra-se na pasta \emph{app}.
\item A lista de dependências externas encontra-se no ficheiro \emph{package.yaml}.
\end{itemize}

\noindent Pode aceder ao \GHCi\ utilizando o comando:
\begin{tabbing}\ttfamily
~stack~ghci
\end{tabbing}

\noindent Garanta que se encontra na pasta mais externa \textbf{do projeto}.
A primeira vez que correr este comando as depêndencias externas serão instaladas automaticamente. Para gerar o PDF, garanta que se encontra na diretoria \emph{app}.

\subsection{Como exprimir cálculos e diagramas em LaTeX/lhs2tex}
Como primeiro exemplo, estudar o texto fonte deste trabalho para obter o
efeito:\footnote{Exemplos tirados de \cite{Ol18}.}
\begin{eqnarray*}
\start
     \ensuremath{\Varid{id}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ universal property }
%
        \ensuremath{\begin{lcbr}\p1\comp \Varid{id}\mathrel{=}\Varid{f}\\\p2\comp \Varid{id}\mathrel{=}\Varid{g}\end{lcbr}}
%
\just\equiv{ identity }
%
        \ensuremath{\begin{lcbr}\p1\mathrel{=}\Varid{f}\\\p2\mathrel{=}\Varid{g}\end{lcbr}}
\qed
\end{eqnarray*}

Os diagramas podem ser produzidos recorrendo à \emph{package} \LaTeX\
\href{https://ctan.org/pkg/xymatrix}{xymatrix}, por exemplo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\cataNat{\Varid{g}}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\cataNat{\Varid{g}}}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\Conid{B}}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{B}}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

\section{Código fornecido}\label{sec:codigo}

\subsection*{Problema 1}

Sequência de transações para teste:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{trs}\mathrel{=}[\mskip1.5mu (\text{\ttfamily \char34 compra\char34},{}\<[21]%
\>[21]{}\text{\ttfamily \char34 20211102\char34},\mathbin{-}\mathrm{50}),{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\text{\ttfamily \char34 venda\char34},{}\<[21]%
\>[21]{}\text{\ttfamily \char34 20211103\char34},\mathrm{100}),{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\text{\ttfamily \char34 despesa\char34},\text{\ttfamily \char34 20212103\char34},\mathbin{-}\mathrm{20}),{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\text{\ttfamily \char34 venda\char34},{}\<[21]%
\>[21]{}\text{\ttfamily \char34 20211205\char34},\mathrm{250}),{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\text{\ttfamily \char34 venda\char34},{}\<[21]%
\>[21]{}\text{\ttfamily \char34 20211205\char34},\mathrm{120})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{getEvenBlock}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{getEvenBlock}\;\Varid{l}\mathrel{=}\mathbf{if}\;(\Varid{even}\;(\length \;\Varid{l}))\;\mathbf{then}\;\Varid{l}\;\mathbf{else}\;\Varid{l}\mathbin{+\!\!\!+}[\mskip1.5mu \Varid{last}\;\Varid{l}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{firsts}\mathrel{=}\alt{\p1}{\p1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 2}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{wc\char95 test}\mathrel{=}\text{\ttfamily \char34 Here~is~a~sentence,~for~testing.\char92 nA~short~one.\char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{sp}\;\Varid{c}\mathrel{=}(\Varid{c}\equiv \text{\ttfamily '~'}\mathrel{\vee}\Varid{c}\equiv \text{\ttfamily '\char92 n'}\mathrel{\vee}\Varid{c}\equiv \text{\ttfamily '\char92 t'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 3}\label{sec:C}
Tipos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{X}\;\Varid{u}\;\Varid{i}\mathrel{=}\Conid{XLeaf}\;\Varid{u}\mid \Conid{Node}\;\Varid{i}\;(\Conid{X}\;\Varid{u}\;\Varid{i})\;(\Conid{X}\;\Varid{u}\;\Varid{i})\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{Frame}\;\Varid{i}\mathrel{=}\Conid{Frame}\;\Varid{i}\;\Varid{i}\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Funções da API\footnote{
API (=``Application Program Interface'').
}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{printJournal}\mathbin{::}\Conid{Sheet}\;\Conid{String}\;\Conid{String}\;\Conid{Double}\to \fun{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{printJournal}\mathrel{=}\Varid{write}\comp \Varid{sheet2html}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{write}\mathbin{::}\Conid{String}{}\<[18]%
\>[18]{}\to \fun{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{write}\;\Varid{s}\mathrel{=}\mathbf{do}\;\Varid{writeFile}\;\text{\ttfamily \char34 jornal.html\char34}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{14}{}\<[14]%
\>[14]{}\Varid{putStrLn}\;\text{\ttfamily \char34 Output~HTML~written~into~file~`jornal.html'\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Geração de HTML: \label{sec:html}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}c<{\hspost}@{}}%
\column{36E}{@{}l@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sheet2html}\;(\Conid{Rect}\;(\Conid{Frame}\;\Varid{w}\;\Varid{h})\;\Varid{y})\mathrel{=}\Varid{htmlwrap}\;(\Varid{x2html}\;\Varid{y}\;(\Varid{w},\Varid{h})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{x2html}\mathbin{::}\Conid{X}\;(\Conid{Unit}\;\Conid{String}\;\Conid{String})\;(\Conid{Mode}\;\Conid{Double})\to (\Conid{Double},\Conid{Double})\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{x2html}\;(\Conid{XLeaf}\;(\Conid{Image}\;\Varid{i}))\;(\Varid{w},\Varid{h})\mathrel{=}\Varid{img}\;\Varid{w}\;\Varid{h}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{x2html}\;(\Conid{XLeaf}\;(\Conid{Text}\;\Varid{txt}))\;\anonymous \mathrel{=}\Varid{txt}{}\<[E]%
\\
\>[B]{}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Vt}\;\Varid{i})\;\Varid{x1}\;\Varid{x2})\;(\Varid{w},\Varid{h})\mathrel{=}\Varid{htab}\;\Varid{w}\;\Varid{h}\;({}\<[E]%
\\
\>[B]{}\hsindent{38}{}\<[38]%
\>[38]{}\Varid{tr}\;(\Varid{td}\;\Varid{w}\;(\Varid{h}\mathbin{*}\Varid{i})\;{}\<[57]%
\>[57]{}(\Varid{x2html}\;\Varid{x1}\;(\Varid{w},\Varid{h}\mathbin{*}\Varid{i})))\mathbin{+\!\!\!+}{}\<[E]%
\\
\>[B]{}\hsindent{38}{}\<[38]%
\>[38]{}\Varid{tr}\;(\Varid{td}\;\Varid{w}\;(\Varid{h}\mathbin{*}(\mathrm{1}\mathbin{-}\Varid{i}))\;(\Varid{x2html}\;\Varid{x2}\;(\Varid{w},\Varid{h}\mathbin{*}(\mathrm{1}\mathbin{-}\Varid{i})))){}\<[E]%
\\
\>[B]{}\hsindent{36}{}\<[36]%
\>[36]{}){}\<[36E]%
\\
\>[B]{}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Hl}\;\Varid{i})\;\Varid{x1}\;\Varid{x2})\;(\Varid{w},\Varid{h})\mathrel{=}\Varid{htab}\;\Varid{w}\;\Varid{h}\;({}\<[E]%
\\
\>[B]{}\hsindent{38}{}\<[38]%
\>[38]{}\Varid{tr}\;(\Varid{td}\;(\Varid{w}\mathbin{*}\Varid{i})\;\Varid{h}\;{}\<[57]%
\>[57]{}(\Varid{x2html}\;\Varid{x1}\;(\Varid{w}\mathbin{*}\Varid{i},\Varid{h}))\mathbin{+\!\!\!+}{}\<[E]%
\\
\>[38]{}\hsindent{4}{}\<[42]%
\>[42]{}\Varid{td}\;(\Varid{w}\mathbin{*}(\mathrm{1}\mathbin{-}\Varid{i}))\;\Varid{h}\;(\Varid{x2html}\;\Varid{x2}\;(\Varid{w}\mathbin{*}(\mathrm{1}\mathbin{-}\Varid{i}),\Varid{h}))){}\<[E]%
\\
\>[B]{}\hsindent{36}{}\<[36]%
\>[36]{}){}\<[36E]%
\\[\blanklineskip]%
\>[B]{}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Vb}\;\Varid{i})\;\Varid{x1}\;\Varid{x2})\;\Varid{m}\mathrel{=}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Vt}\;(\mathrm{1}\mathbin{-}\Varid{i}))\;\Varid{x1}\;\Varid{x2})\;\Varid{m}{}\<[E]%
\\
\>[B]{}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Hr}\;\Varid{i})\;\Varid{x1}\;\Varid{x2})\;\Varid{m}\mathrel{=}\Varid{x2html}\;(\Conid{Node}\;(\Conid{Hl}\;(\mathrm{1}\mathbin{-}\Varid{i}))\;\Varid{x1}\;\Varid{x2})\;\Varid{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Funções auxiliares: \label{sec:faux}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{twoVtImg}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Node}\;(\Conid{Vt}\;\mathrm{0.5})\;(\Conid{XLeaf}\;(\Conid{Image}\;\Varid{a}))\;(\Conid{XLeaf}\;(\Conid{Image}\;\Varid{b})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{fourInArow}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{d}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.5})\;{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}(\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.5})\;(\Conid{XLeaf}\;(\Conid{Text}\;\Varid{a}))\;(\Conid{XLeaf}\;(\Conid{Text}\;\Varid{b})))\;{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}(\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.5})\;(\Conid{XLeaf}\;(\Conid{Text}\;\Varid{c}))\;(\Conid{XLeaf}\;(\Conid{Text}\;\Varid{d}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
HTML:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{htmlwrap}\mathrel{=}\Varid{html}\comp \Varid{hd}\comp (\Varid{title}\;\text{\ttfamily \char34 CP/2122~-~sheet2html\char34})\comp \Varid{body}\comp \Varid{divt}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{html}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 html\char34}\;[\mskip1.5mu \mskip1.5mu]\comp (\text{\ttfamily \char34 <meta~charset=\char92 \char34 utf-8\char92 \char34 ~/>\char34}\mathbin{+\!\!\!+}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{title}\;\Varid{t}\mathrel{=}(\Varid{tag}\;\text{\ttfamily \char34 title\char34}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{t}\mathbin{+\!\!\!+}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{body}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 body\char34}\;[\mskip1.5mu \text{\ttfamily \char34 BGCOLOR\char34}\mapsto\Varid{show}\;\text{\ttfamily \char34 \#F4EFD8\char34}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hd}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 head\char34}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{htab}\;\Varid{w}\;\Varid{h}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 table\char34}\;[\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 width\char34}\mapsto\Varid{show2}\;\Varid{w},\text{\ttfamily \char34 height\char34}\mapsto\Varid{show2}\;\Varid{h},{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 cellpadding\char34}\mapsto\Varid{show2}\;\mathrm{0},\text{\ttfamily \char34 border\char34}\mapsto\Varid{show}\;\text{\ttfamily \char34 1px\char34}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tr}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 tr\char34}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{td}\;\Varid{w}\;\Varid{h}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 td\char34}\;[\mskip1.5mu \text{\ttfamily \char34 width\char34}\mapsto\Varid{show2}\;\Varid{w},\text{\ttfamily \char34 height\char34}\mapsto\Varid{show2}\;\Varid{h}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{divt}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 div\char34}\;[\mskip1.5mu \text{\ttfamily \char34 align\char34}\mapsto\Varid{show}\;\text{\ttfamily \char34 center\char34}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{img}\;\Varid{w}\;\Varid{h}\;\Varid{i}\mathrel{=}\Varid{tag}\;\text{\ttfamily \char34 img\char34}\;[\mskip1.5mu \text{\ttfamily \char34 width\char34}\mapsto\Varid{show2}\;\Varid{w},\text{\ttfamily \char34 src\char34}\mapsto\Varid{show}\;\Varid{i}\mskip1.5mu]\;\text{\ttfamily \char34 \char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tag}\;\Varid{t}\;\Varid{l}\;\Varid{x}\mathrel{=}\text{\ttfamily \char34 <\char34}\mathbin{+\!\!\!+}\Varid{t}\mathbin{+\!\!\!+}\text{\ttfamily \char34 ~\char34}\mathbin{+\!\!\!+}\Varid{ps}\mathbin{+\!\!\!+}\text{\ttfamily \char34 >\char34}\mathbin{+\!\!\!+}\Varid{x}\mathbin{+\!\!\!+}\text{\ttfamily \char34 </\char34}\mathbin{+\!\!\!+}\Varid{t}\mathbin{+\!\!\!+}\text{\ttfamily \char34 >\char92 n\char34}{}\<[E]%
\\
\>[B]{}\hsindent{14}{}\<[14]%
\>[14]{}\mathbf{where}\;\Varid{ps}\mathrel{=}\Varid{unwords}\;[\mskip1.5mu \Varid{concat}\;[\mskip1.5mu \Varid{t},\text{\ttfamily \char34 =\char34},\Varid{v}\mskip1.5mu]\mid (\Varid{t},\Varid{v})\leftarrow \Varid{l}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{a}\mapsto\Varid{b}\mathrel{=}(\Varid{a},\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{show2}\mathbin{::}\Conid{Show}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{show2}\mathrel{=}\Varid{show}\comp \Varid{show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Exemplo para teste: \label{sec:test_data}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{example}\mathbin{::}(\Conid{Fractional}\;\Varid{i})\Rightarrow \Conid{Sheet}\;\Conid{String}\;\Conid{String}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{example}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{Rect}\;(\Conid{Frame}\;\mathrm{650}\;\mathrm{450})\;{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}(\Conid{Node}\;(\Conid{Vt}\;\mathrm{0.01})\;{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}(\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.15})\;{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}(\Conid{XLeaf}\;(\Conid{Image}\;\text{\ttfamily \char34 cp2122t\char95 media/publico.jpg\char34}))\;{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{}(\Varid{fourInArow}\;\text{\ttfamily \char34 Jornal~Público\char34}\;\text{\ttfamily \char34 Domingo,~5~de~Dezembro~2021\char34}\;\text{\ttfamily \char34 Simulação~para~efeitos~escolares\char34}\;\text{\ttfamily \char34 CP/2122-TP\char34}))\;{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}(\Conid{Node}\;(\Conid{Vt}\;\mathrm{0.55})\;{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}(\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.55})\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}(\Conid{Node}\;(\Conid{Vt}\;\mathrm{0.1})\;{}\<[E]%
\\
\>[15]{}\hsindent{3}{}\<[18]%
\>[18]{}(\Conid{XLeaf}\;(\Conid{Text}{}\<[E]%
\\
\>[15]{}\hsindent{3}{}\<[18]%
\>[18]{}\text{\ttfamily \char34 Universidade~do~Algarve~estuda~planta~capaz~de~eliminar~a~doença~do~sobreiro\char34}))\;{}\<[E]%
\\
\>[15]{}\hsindent{3}{}\<[18]%
\>[18]{}(\Conid{XLeaf}\;(\Conid{Text}{}\<[E]%
\\
\>[18]{}\hsindent{1}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 Organismo~(semelhante~a~um~fungo)~ataca~de~forma~galopante~os~montados~de~sobro.~O~contra-poder~para~fazer~recuar~o~agente~destruidor~reside~numa~planta~(marioila),~que~nasce~espontânea~no~Algarve~e~Alentejo.\char92 nComo~travar~o~declínio~do~sobreiro?~A~árvore,~classificada~como~Património~Nacional~de~Portugal~desde~Dezembro~de~2011,~continua~numa~lenta~agonia.~O~processo~destrutivo~-~ainda~sem~fim~à~vista~à~vista~-~pode~agora~ser~estancado.~(...)\char34})))\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}(\Conid{XLeaf}\;(\Conid{Image}{}\<[E]%
\\
\>[15]{}\hsindent{4}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 cp2122t\char95 media/1647472.jpg\char34})))\;{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}(\Conid{Node}\;(\Conid{Hl}\;\mathrm{0.25})\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}(\Varid{twoVtImg}\;{}\<[E]%
\\
\>[15]{}\hsindent{4}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 cp2122t\char95 media/1647981.jpg\char34}\;{}\<[E]%
\\
\>[15]{}\hsindent{4}{}\<[19]%
\>[19]{}\text{\ttfamily \char34 cp2122t\char95 media/1647982.jpg\char34})\;{}\<[E]%
\\
\>[11]{}\hsindent{4}{}\<[15]%
\>[15]{}(\Conid{Node}\;(\Conid{Vt}\;\mathrm{0.1})\;{}\<[E]%
\\
\>[15]{}\hsindent{4}{}\<[19]%
\>[19]{}(\Conid{XLeaf}\;(\Conid{Text}\;\text{\ttfamily \char34 Manchester~United~vence~na~estreia~de~Rangnick\char34}))\;{}\<[E]%
\\
\>[15]{}\hsindent{4}{}\<[19]%
\>[19]{}(\Conid{XLeaf}\;(\Conid{Text}\;\text{\ttfamily \char34 O~Manchester~United~venceu,~este~domingo,~em~Old~Trafford,~na~estreia~do~treinador~alemão~Ralf~Rangnick,~impondo-se~por~1-0~frente~ao~Crystal~Palace~de~Patrick~Vieira~graças~a~um~golo~do~brasileiro~Fred,~já~no~último~quarto~de~hora~da~partida~da~15.ª~ronda~da~Liga~inglesa.~(...)\char34})))))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 4}\label{sec:D}
Exemplos de mapas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}map_1 \mathrel{=}[\mskip1.5mu [\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Free},\Conid{Free}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}map_2 \mathrel{=}[\mskip1.5mu [\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Free},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}map_3\mathrel{=}[\mskip1.5mu [\mskip1.5mu \Conid{Free},\Conid{Free},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu],[\mskip1.5mu \Conid{Free},\Conid{Blocked},\Conid{Free}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Código para impressões de mapas e caminhos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{showM}\mathbin{::}\Conid{Map}\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{showM}\mathrel{=}\Varid{unlines}\comp (\map \;\Varid{showL})\comp \Varid{reverse}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{showL}{}\<[8]%
\>[8]{}\mathbin{::}[\mskip1.5mu \Conid{Cell}\mskip1.5mu]\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{showL}\mathrel{=}\cataList{\alt{f_1 }{f_2 }}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_1 \mathrel{=}\underline{\text{\ttfamily \char34 \char34}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_2 \mathrel{=}\uncurry{(\mathbin{+\!\!\!+})}\comp (\Varid{fromCell}\times\Varid{id}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{fromCell}\;\Conid{Lft}\mathrel{=}\text{\ttfamily \char34 ~>~\char34}{}\<[E]%
\\
\>[B]{}\Varid{fromCell}\;\Conid{Rght}\mathrel{=}\text{\ttfamily \char34 ~<~\char34}{}\<[E]%
\\
\>[B]{}\Varid{fromCell}\;\Conid{Up}\mathrel{=}\text{\ttfamily \char34 ~\char94 ~\char34}{}\<[E]%
\\
\>[B]{}\Varid{fromCell}\;\Conid{Down}\mathrel{=}\text{\ttfamily \char34 ~v~\char34}{}\<[E]%
\\
\>[B]{}\Varid{fromCell}\;\Conid{Free}\mathrel{=}\text{\ttfamily \char34 ~\char95 ~\char34}{}\<[E]%
\\
\>[B]{}\Varid{fromCell}\;\Conid{Blocked}\mathrel{=}\text{\ttfamily \char34 ~X~\char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{toCell}\;(\Varid{x},\Varid{y})\;(\Varid{w},\Varid{z})\mid \Varid{x}\mathbin{<}\Varid{w}\mathrel{=}\Conid{Lft}{}\<[E]%
\\
\>[B]{}\Varid{toCell}\;(\Varid{x},\Varid{y})\;(\Varid{w},\Varid{z})\mid \Varid{x}\mathbin{>}\Varid{w}\mathrel{=}\Conid{Rght}{}\<[E]%
\\
\>[B]{}\Varid{toCell}\;(\Varid{x},\Varid{y})\;(\Varid{w},\Varid{z})\mid \Varid{y}\mathbin{<}\Varid{z}\mathrel{=}\Conid{Up}{}\<[E]%
\\
\>[B]{}\Varid{toCell}\;(\Varid{x},\Varid{y})\;(\Varid{w},\Varid{z})\mid \Varid{y}\mathbin{>}\Varid{z}\mathrel{=}\Conid{Down}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\noindent
Código para validação de mapas (útil, por exemplo, para testes
\QuickCheck):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ncols}\mathbin{::}\Conid{Map}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{ncols}\mathrel{=}\alt{\underline{\mathrm{0}}}{\length \comp \p1}\comp \Varid{outList}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{nlines}\mathbin{::}\Conid{Map}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{nlines}\mathrel{=}\length {}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{isValidMap}\mathbin{::}\Conid{Map}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{isValidMap}\mathrel{=}\uncurry{(\mathrel{\wedge})}\comp \conj{\Varid{isSquare}}{\Varid{sameLength}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{isSquare}\mathrel{=}\uncurry{(\equiv )}\comp \conj{\Varid{nlines}}{\Varid{ncols}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{sameLength}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{sameLength}\;[\mskip1.5mu \Varid{x}\mskip1.5mu]\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{sameLength}\;(\Varid{x1}\mathbin{:}\Varid{x2}\mathbin{:}\Varid{y})\mathrel{=}\length \;\Varid{x1}\equiv \length \;\Varid{x2}\mathrel{\wedge}\Varid{sameLength}\;(\Varid{x2}\mathbin{:}\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\noindent
Código para geração aleatória de mapas e automatização de testes
(envolve o mónade IO):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{randomRIOL}\mathbin{::}(\Conid{Random}\;\Varid{a})\Rightarrow (\Varid{a},\Varid{a})\to \Conid{Int}\to \fun{IO}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{randomRIOL}\;\Varid{x}\mathrel{=}\cataNat{\alt{f_1 }{f_2 }}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_1 \mathrel{=}\underline{\Varid{return}\;[\mskip1.5mu \mskip1.5mu]}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_2 \;\Varid{l}\mathrel{=}\mathbf{do}\;\Varid{r1}\leftarrow \Varid{randomRIO}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}\Varid{r2}\leftarrow \Varid{l}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}\Varid{return}\mathbin{\$}\Varid{r1}\mathbin{:}\Varid{r2}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{buildMat}\mathbin{::}\Conid{Int}\to \Conid{Int}\to \fun{IO}\;[\mskip1.5mu [\mskip1.5mu \Conid{Int}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{buildMat}\;\Varid{n}\mathrel{=}\cataNat{\alt{f_1 }{f_2 }}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_1 \mathrel{=}\underline{\Varid{return}\;[\mskip1.5mu \mskip1.5mu]}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_2 \;\Varid{l}\mathrel{=}\mathbf{do}\;\Varid{x}\leftarrow \Varid{randomRIOL}\;(\mathrm{0}\mathbin{::}\Conid{Int},\mathrm{3}\mathbin{::}\Conid{Int})\;\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}\Varid{y}\leftarrow \Varid{l}{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}\Varid{return}\mathbin{\$}\Varid{x}\mathbin{:}\Varid{y}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{testWithRndMap}\mathbin{::}\fun{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{testWithRndMap}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{dim}\leftarrow \Varid{randomRIO}\;(\mathrm{2},\mathrm{10})\mathbin{::}\fun{IO}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{out}\leftarrow \Varid{buildMat}\;\Varid{dim}\;\Varid{dim}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\map \leftarrow \Varid{return}\mathbin{\$}\map \;(\map \;\Varid{table})\;\Varid{out}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{putStr}\mathbin{\$}\Varid{showM}\;\map {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{putStrLn}\mathbin{\$}\text{\ttfamily \char34 Map~of~dimension~\char34}\mathbin{+\!\!\!+}(\Varid{show}\;\Varid{dim})\mathbin{+\!\!\!+}\text{\ttfamily \char34 x\char34}\mathbin{+\!\!\!+}(\Varid{show}\;\Varid{dim})\mathbin{+\!\!\!+}\text{\ttfamily \char34 .\char34}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{putStr}\;\text{\ttfamily \char34 Please~provide~a~target~position~(must~be~different~from~(0,0)):~\char34}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{t}\leftarrow \Varid{readLn}\mathbin{::}\fun{IO}\;(\Conid{Int},\Conid{Int}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{putStr}\;\text{\ttfamily \char34 Please~provide~the~number~of~steps~to~compute:~\char34}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{n}\leftarrow \Varid{readLn}\mathbin{::}\fun{IO}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{let}\;\Varid{paths}\mathrel{=}\Varid{hasTarget}\;\Varid{t}\;(\Varid{scout}\;\map \;(\mathrm{0},\mathrm{0})\;\Varid{t}\;\Varid{n})\;\mathbf{in}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{if}\;\length \;\Varid{paths}\equiv \mathrm{0}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{then}\;\Varid{putStrLn}\;\text{\ttfamily \char34 No~paths~found.\char34}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{else}\;\Varid{putStrLn}\mathbin{\$}\text{\ttfamily \char34 There~are~at~least~\char34}\mathbin{+\!\!\!+}(\Varid{show}\mathbin{\$}\length \;\Varid{paths})\mathbin{+\!\!\!+}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\text{\ttfamily \char34 ~possible~paths.~Here~is~one~case:~\char92 n\char34}\mathbin{+\!\!\!+}(\Varid{showM}\mathbin{\$}\Varid{markMap}\;(\Varid{head}\;\Varid{paths})\;\map ){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{table}\;\mathrm{0}\mathrel{=}\Conid{Free}{}\<[E]%
\\
\>[B]{}\Varid{table}\;\mathrm{1}\mathrel{=}\Conid{Free}{}\<[E]%
\\
\>[B]{}\Varid{table}\;\mathrm{2}\mathrel{=}\Conid{Free}{}\<[E]%
\\
\>[B]{}\Varid{table}\;\mathrm{3}\mathrel{=}\Conid{Blocked}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hasTarget}\;\Varid{y}\mathrel{=}\Varid{filter}\;(\lambda \Varid{l}\to \Varid{elem}\;\Varid{y}\;\Varid{l}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Funções auxiliares}
\ensuremath{\Varid{subst}\mathbin{::}\Varid{a}\to \Conid{Int}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]}, que dado um valor \ensuremath{\Varid{x}} e um inteiro \ensuremath{\Varid{n}},
produz uma função \ensuremath{\Varid{f}\mathbin{:}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]} que dada uma lista \ensuremath{\Varid{l}} substitui o valor na posição
\ensuremath{\Varid{n}} dessa lista pelo valor \ensuremath{\Varid{x}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{subst}\mathbin{::}\Varid{a}\to \Conid{Int}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{subst}\;\Varid{x}\mathrel{=}\cataNat{\alt{f_1 }{f_2 }}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_1 \mathrel{=}\underline{\lambda \Varid{l}\to \Varid{x}\mathbin{:}\Varid{tail}\;\Varid{l}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_2 \;\Varid{f}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\Varid{h}\mathbin{:}\Varid{f}\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ensuremath{\Varid{checkAround}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]}, que
verifica se as células adjacentes estão livres:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Pos}\mathrel{=}(\Conid{Int},\Conid{Int}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{checkAround}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{checkAround}\;\Varid{m}\;\Varid{p}\mathrel{=}\Varid{concat}\mathbin{\$}\map \;(\lambda \Varid{f}\to \Varid{f}\;\Varid{m}\;\Varid{p}){}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}[\mskip1.5mu \Varid{checkLeft},\Varid{checkRight},\Varid{checkUp},\Varid{checkDown}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{checkLeft}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{checkLeft}\;\Varid{m}\;(\Varid{x},\Varid{y})\mathrel{=}\mathbf{if}\;\Varid{x}\equiv \mathrm{0}\mathrel{\vee}(\Varid{m}\mathbin{!!}\Varid{y})\mathbin{!!}(\Varid{x}\mathbin{-}\mathrm{1})\equiv \Conid{Blocked}{}\<[E]%
\\
\>[B]{}\hsindent{21}{}\<[21]%
\>[21]{}\mathbf{then}\;[\mskip1.5mu \mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu (\Varid{x}\mathbin{-}\mathrm{1},\Varid{y})\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{checkRight}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{checkRight}\;\Varid{m}\;(\Varid{x},\Varid{y})\mathrel{=}\mathbf{if}\;\Varid{x}\equiv (\Varid{ncols}\;\Varid{m}\mathbin{-}\mathrm{1})\mathrel{\vee}(\Varid{m}\mathbin{!!}\Varid{y})\mathbin{!!}(\Varid{x}\mathbin{+}\mathrm{1})\equiv \Conid{Blocked}{}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\mathbf{then}\;[\mskip1.5mu \mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu (\Varid{x}\mathbin{+}\mathrm{1},\Varid{y})\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{checkUp}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{checkUp}\;\Varid{m}\;(\Varid{x},\Varid{y})\mathrel{=}\mathbf{if}\;\Varid{y}\equiv (\Varid{nlines}\;\Varid{m}\mathbin{-}\mathrm{1})\mathrel{\vee}(\Varid{m}\mathbin{!!}(\Varid{y}\mathbin{+}\mathrm{1}))\mathbin{!!}\Varid{x}\equiv \Conid{Blocked}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\mathbf{then}\;[\mskip1.5mu \mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu (\Varid{x},\Varid{y}\mathbin{+}\mathrm{1})\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{checkDown}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to [\mskip1.5mu \Conid{Pos}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{checkDown}\;\Varid{m}\;(\Varid{x},\Varid{y})\mathrel{=}\mathbf{if}\;\Varid{y}\equiv \mathrm{0}\mathrel{\vee}(\Varid{m}\mathbin{!!}(\Varid{y}\mathbin{-}\mathrm{1}))\mathbin{!!}\Varid{x}\equiv \Conid{Blocked}{}\<[E]%
\\
\>[B]{}\hsindent{21}{}\<[21]%
\>[21]{}\mathbf{then}\;[\mskip1.5mu \mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu (\Varid{x},\Varid{y}\mathbin{-}\mathrm{1})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection*{QuickCheck}

%----------------- Outras definições auxiliares -------------------------------------------%
Lógicas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{infixr}\;\mathrm{0}\Rightarrow{}\<[E]%
\\
\>[B]{}(\Rightarrow)\mathbin{::}(\Conid{Testable}\;\Varid{prop})\Rightarrow (\Varid{a}\to \Conid{Bool})\to (\Varid{a}\to \Varid{prop})\to \Varid{a}\to \Conid{Property}{}\<[E]%
\\
\>[B]{}\Varid{p}\Rightarrow\Varid{f}\mathrel{=}\lambda \Varid{a}\to \Varid{p}\;\Varid{a}\Rightarrow\Varid{f}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{infixr}\;\mathrm{0}\Leftrightarrow{}\<[E]%
\\
\>[B]{}(\Leftrightarrow)\mathbin{::}(\Varid{a}\to \Conid{Bool})\to (\Varid{a}\to \Conid{Bool})\to \Varid{a}\to \Conid{Property}{}\<[E]%
\\
\>[B]{}\Varid{p}\Leftrightarrow\Varid{f}\mathrel{=}\lambda \Varid{a}\to (\Varid{p}\;\Varid{a}\Rightarrow\Varid{property}\;(\Varid{f}\;\Varid{a}))\mathbin{.\&\&.}(\Varid{f}\;\Varid{a}\Rightarrow\Varid{property}\;(\Varid{p}\;\Varid{a})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{infixr}\;\mathrm{4}\equiv{}\<[E]%
\\
\>[B]{}(\equiv)\mathbin{::}\Conid{Eq}\;\Varid{b}\Rightarrow (\Varid{a}\to \Varid{b})\to (\Varid{a}\to \Varid{b})\to (\Varid{a}\to \Conid{Bool}){}\<[E]%
\\
\>[B]{}\Varid{f}\equiv\Varid{g}\mathrel{=}\lambda \Varid{a}\to \Varid{f}\;\Varid{a}\equiv \Varid{g}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{infixr}\;\mathrm{4}\leq{}\<[E]%
\\
\>[B]{}(\leq)\mathbin{::}\Conid{Ord}\;\Varid{b}\Rightarrow (\Varid{a}\to \Varid{b})\to (\Varid{a}\to \Varid{b})\to (\Varid{a}\to \Conid{Bool}){}\<[E]%
\\
\>[B]{}\Varid{f}\leq\Varid{g}\mathrel{=}\lambda \Varid{a}\to \Varid{f}\;\Varid{a}\leq \Varid{g}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{infixr}\;\mathrm{4}\wedge{}\<[E]%
\\
\>[B]{}(\wedge)\mathbin{::}(\Varid{a}\to \Conid{Bool})\to (\Varid{a}\to \Conid{Bool})\to (\Varid{a}\to \Conid{Bool}){}\<[E]%
\\
\>[B]{}\Varid{f}\wedge\Varid{g}\mathrel{=}\lambda \Varid{a}\to ((\Varid{f}\;\Varid{a})\mathrel{\wedge}(\Varid{g}\;\Varid{a})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Arbitrary}\;\Conid{Cell}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mbox{\onelinecomment  1/4 chance of generating a cell 'Block'.}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{arbitrary}\mathrel{=}\mathbf{do}\;\Varid{x}\leftarrow \Varid{chooseInt}\;(\mathrm{0},\mathrm{3}){}\<[E]%
\\
\>[3]{}\hsindent{15}{}\<[18]%
\>[18]{}\Varid{return}\mathbin{\$}\Varid{f}\;\Varid{x}\;\mathbf{where}{}\<[E]%
\\
\>[18]{}\hsindent{2}{}\<[20]%
\>[20]{}\Varid{f}\;\Varid{x}\mathrel{=}\mathbf{if}\;\Varid{x}\mathbin{<}\mathrm{3}\;\mathbf{then}\;\Conid{Free}\;\mathbf{else}\;\Conid{Blocked}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Soluções dos alunos -----------------------------------------%

\section{Soluções dos alunos}\label{sec:resolucao}

\subsection*{Problema 1} \label{pg:P1}

\par \hspace{0.5cm}Para grarantir que \ensuremath{\Varid{list2LTree}} não aceita listas vazias é pedido para definir \ensuremath{\Varid{outNEList}}.
Uma vez que conhecemos o \ensuremath{\Varid{inNEList}} podemos calcular o seu inverso da seguinte forma:

\begin{eqnarray*}
\start
  outNEList\ .\ inNEList  = id
%
\just\equiv{\textcolor{blue}{inNEList}}
%
  outNEList\ .\ [ single ,\ cons] = id
%
\just\equiv{\textcolor{blue}{Fusão-+\ (20)}}
%
  [outNEList\ .\  single,\ outNEList\ .\  cons] = id
%
\just\equiv{\textcolor{blue}{Universal-+\ (17)}}
%
      \ensuremath{\begin{lcbr}\Varid{id}\comp i_1\mathrel{=}\Varid{outNEList}\comp \Varid{single}\\\Varid{id}\comp i_2\mathrel{=}\Varid{outNEList}\comp \Varid{cons}\end{lcbr}}
%
\just\equiv{\textcolor{blue}{Natural-id\ (1),\ Igualdade\ Extensional\ (69),\ Def-comp\ (70)}}
%
      \ensuremath{\begin{lcbr}\Varid{outNEList}\;(\Varid{single}\;\Varid{a})\mathrel{=}i_1\;\Varid{a}\\\Varid{outNEList}\;(\Varid{cons}\;(\Varid{h},\Varid{t}))\mathrel{=}i_2\;(\Varid{h},\Varid{t})\end{lcbr}}
\end{eqnarray*}

\vspace{0.5cm}
Assim o tipo do \ensuremath{\Varid{outNEList}} é:
\vspace{0.5cm}

\xymatrixcolsep{2pc}\xymatrixrowsep{6pc}
\centerline{\xymatrix{
   A^+\
                \ar@/^2pc/ [rr]^-{\ensuremath{\Varid{outNEList}}} & \qquad \cong
&    A + A \times A^+
      \ar@/^2pc/ [ll]^-{\ensuremath{\Varid{inNEList}}}
\\
}}

\vspace{0.5cm}
Listas não vazias:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}c<{\hspost}@{}}%
\column{15E}{@{}l@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{outNEList}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[17]%
\>[17]{}\mathrel{=}i_1\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{outNEList}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}i_2\;(\Varid{h},\Varid{t}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{baseNEList}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{f}+(\Varid{f}\times\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recNEList}\;{}\<[12]%
\>[12]{}\Varid{f}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{baseNEList}\;\Varid{id}\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataNEList}\;\Varid{g}{}\<[15]%
\>[15]{}\mathrel{=}{}\<[15E]%
\>[18]{}\Varid{g}\comp \Varid{recNEList}\;(\Varid{cataNEList}\;{}\<[45]%
\>[45]{}\Varid{g})\comp \Varid{outNEList}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaNEList}\;{}\<[12]%
\>[12]{}\Varid{g}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{inNEList}\comp \Varid{recNEList}\;(\Varid{anaNEList}\;\Varid{g})\comp \Varid{g}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloNEList}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataNEList}\;\Varid{h}\comp \Varid{anaNEList}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\vspace{0.5cm}
Gene do anamorfismo:
\vspace{0.5cm}\par
Para descobrir o gene do anamorfismo, recorremos ao diagrama do anamorfismo das \ensuremath{{\LTree}}.
\vspace{0.5cm}

\xymatrixcolsep{1pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
   A^+\ \ar[d]_-{\ensuremath{\anaList{\Varid{g\char95 list2LTree}}}}
            \ar[rr]^-{\ensuremath{\Varid{g\char95 list2LTree}}} & \qquad
&    A + A^+ \times A^+  \ar[d]^{\ensuremath{\Varid{recLTree}\;\anaList{\Varid{g\char95 list2LTree}}}}
\\
    LTree\ A \ar@/^2pc/ [rr]^-{\ensuremath{\mathsf{out}}} & \qquad \cong
     &  A + LTree\ A \times LTree\ A
      \ar@/^2pc/ [ll]^-{\ensuremath{\mathsf{in}}}
}}

\vspace{0.5cm}
Primeiramente percebemos que o gene recebe uma lista não vazia e produz duas listas não vazias,
ou no caso da lista singular devolve o elemento.
Uma vez que estamos a trabalhar com listas não vazias resolvemos aplicar o \ensuremath{\Varid{outNElist}} que definimos anteriormente.
Assim ficamos com o tipo \ensuremath{\Conid{A}\mathbin{+}\Conid{A}\times\Conid{A}\mathbin{\char94 +}}. Para ficar com o tipo pretendido, à direita, definimos uma função auxiliar,
\ensuremath{\Varid{splitHalf}} que, com o auxilio da função pré-definida, \ensuremath{\Varid{splitAt}}, divide recebe um par elemento lista e divide a meio a lista,
produzindo um par com as duas metades da lista.

\begin{center}
\fbox{\begin{minipage}{30em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g\char95 list2LTree}\mathrel{=}{}\<[17]%
\>[17]{}(\Varid{id}+\Varid{splitHalf})\comp \Varid{outNEList}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{splitHalf}\;(\Varid{a},\Varid{b})\mathrel{=}\Varid{splitAt}\;((\length \;\Varid{b}\mathbin{+}\mathrm{1})\mathbin{\Varid{`div`}}\mathrm{2})\;(\Varid{a}\mathbin{:}\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}
\vspace{0.5cm}
Gene do catamorfismo:
\vspace{0.5cm}

\xymatrixcolsep{2pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
   LTree\ A\ \ar[d]_-{\ensuremath{\cataNat{\Varid{g\char95 lTree2MTree}}}}
                \ar[rr]^-{\ensuremath{\mathsf{out}}} & \qquad
&  A\ + (LTree\ A \times LTree\ A)
  \ar[d]^{\ensuremath{\Varid{recLTree}\;\cataNat{\Varid{g\char95 lTree2MTree}}}}
\\
    Ftree\ \mathbb{Z}\ (\mathbb{Z}\ , A) &
&  A\ + (Ftree\ \mathbb{Z}\ (\mathbb{Z}\ , A) \times Ftree\ \mathbb{Z}\ (\mathbb{Z}\ , A))
    \ar[ll]^-{\ensuremath{\Varid{g\char95 lTree2MTree}}}
}}

\vspace{0.5cm}
Da análise do diagrama retiramos que, este gene, no caso de receber um único elemento,
produz um Unit, ou seja, uma folha, com um par em que o segundo elemento é a
transação e o primeiro o seu valor de \ensuremath{\Varid{hash}}, que calculamos com a auxiliar fornecida \ensuremath{\Varid{hash}}.
No caso de receber duas \ensuremath{{\FTree}} necessitamos as juntar e concatenar os hashs com outra auxiliar fornecida, a \ensuremath{\Varid{concHash}}.
\par Após estudar o conteúdo do ficheiro \ensuremath{\Varid{{\FTree}.hs}} e o enunciado concluimos que, em \ensuremath{{\FTree}\;\Varid{a}\;\Varid{c}}, o \ensuremath{\Varid{a}} é concatenação dos \ensuremath{\Varid{hash}}
e o \ensuremath{\Varid{c}} o par (hash,transação).
\par Para encontrar o valor de hash de uma \ensuremath{{\FTree}} precisamos de definir as seguintes auxiliares:

\par Assim para obter o resultado pretendido usando o \ensuremath{\mathsf{in}} das \ensuremath{{\FTree}} que recebe o tipo:
\par\hspace{0.3cm}\xymatrix{( \mathbb{Z} \times A) + (\mathbb{Z} \times (Ftree\ \mathbb{Z}\ (\mathbb{Z}\ , A) \times Ftree\ \mathbb{Z}\ (\mathbb{Z}\ , A)))}

\begin{center}
\fbox{\begin{minipage}{40em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g\char95 lTree2MTree}\mathbin{::}\Conid{Hashable}\;\Varid{c}\Rightarrow \Varid{c}+({\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{c}),{\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{c}))\to {\FTree}\;\mathbb{Z}\;(\mathbb{Z},\Varid{c}){}\<[E]%
\\
\>[B]{}\Varid{g\char95 lTree2MTree}\mathrel{=}\mathsf{in}\comp (\conj{\Varid{\Conid{Main}.hash}}{{}\<[48]%
\>[48]{}\Varid{id}}+\conj{\Varid{calcHash}}{\Varid{id}})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{getHash}\;(\Conid{Unit}\;\Varid{c})\mathrel{=}\p1\;\Varid{c}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{getHash}\;(\Conid{Comp}\;\Varid{a}\;\anonymous )\mathrel{=}\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{calcHash}\;(\Varid{t1},\Varid{t2})\mathrel{=}\Varid{concHash}\;(\Varid{getHash}\;\Varid{t1},\Varid{getHash}\;\Varid{t2}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}

Gene de \ensuremath{\Varid{mroot}} ("get Merkle root"):
\vspace{0.2cm}
\par Uma vez que \ensuremath{\Varid{computeMerkleTree}} produz uma \ensuremath{\Conid{MerkleTree}} temos que o diagrama de \ensuremath{\Varid{mroot}} é:
\vspace{0.5cm}

\xymatrixcolsep{2pc}\xymatrixrowsep{6pc}
\centerline{\xymatrix{
   FTree\ \mathbb{Z}\ (\mathbb{Z}\ , A) \ar[d]_-{\ensuremath{\cataNat{\Varid{g\char95 mroot}}}}
                \ar[rr]^-{\ensuremath{\mathsf{out}}} & \qquad
&  (\mathbb{Z}\ \times A) + (\mathbb{Z}\ \times (FTree\ \mathbb{Z}\ (\mathbb{Z}\ , A) \times FTree\ \mathbb{Z}\ (\mathbb{Z}\ , A)))
  \ar[d]^{\ensuremath{\Varid{recFTree}\;\cataNat{\Varid{g\char95 mroot}}}}
\\
    \mathbb{Z} &
&  (\mathbb{Z}\ \times A) + \mathbb{Z}\ \times (\mathbb{Z}\ \times \mathbb{Z})
    \ar[ll]^-{\ensuremath{\Varid{g\char95 mroot}}}
}}

\vspace{0.5cm}
Sendo a \ensuremath{\Conid{Merkle}\;\Conid{Root}} o valor de \ensuremath{\Varid{hash}} de todo o bloco, no caso de ser uma àrvore singular
o resultado será a hash da transação, caso contrário a hash do nodo mais exterior, ou seja a raiz.
Como podemos verificar pelo diagrama, o gene será um either dos primeiros elementos,
pelo que podemos usar a auxiliar fornecida \ensuremath{\Varid{firts}}.

\begin{center}
\fbox{\begin{minipage}{12em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g\char95 mroot}\mathrel{=}\Varid{firsts}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}

Quando executamos \ensuremath{\Varid{mroot}\;\Varid{trs}} o valor obtido é -13593070566482620546,
correspondente ao valor de hash da \ensuremath{\Conid{Merkle}\;\Conid{Root}}, ou seja o valor de hash mais exterior
ao executar \ensuremath{\Varid{computeMerkleTree}\;\Varid{trs}}.
Ao alterar uma transação, este valor vai alterado,
conforme a diferença entre os valores de hash que a mudança na transação causou.
\vspace{0.5cm}
\par Valorização:
\vspace{0.5cm}
\par Para descobrir o gene do anamorfismo \ensuremath{\Varid{pairsList}} recorremos ao seu diagrama.
\vspace{0.5cm}

\xymatrixcolsep{2pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
   A^*\ \ar[d]_-{\ensuremath{\anaList{\Varid{g\char95 pairsList}}}}
            \ar[rr]^-{\ensuremath{\Varid{g\char95 list2LTree}}} & \qquad
&    1\ + (A \times A) \times A^*  \ar[d]^{\ensuremath{\Varid{recList}\;\anaList{\Varid{g\char95 pairsList}}}}
\\
    (A,A)^* \ar@/^2pc/ [rr]^-{\ensuremath{\Varid{outList}}} & \qquad \cong
     &  1\ + (A\times A) \times (A,A)^*
      \ar@/^2pc/ [ll]^-{\ensuremath{\Varid{inList}}}
}}

\vspace{0.5cm}
\par Pela análise do diagrama, concluimos que o gene \ensuremath{\Varid{g\char95 pairsList}} recebe uma lista e produz,
ou uma lista vazia ou um par e uma lista. Tendo em conta que a lista tem de ser par, o primeiro passo foi utilizar a auxiliar
\ensuremath{\Varid{getEvenBlock}}. Em seguida utilizamos o \ensuremath{\Varid{outList}}, olhando para o segundo elemento do either produzido por este, concluimos
para obter o par precisavamos de mais um elemento da lista pelo que utilizamos um split, ficando com o tipo: \ensuremath{(\Conid{A}\times(\Conid{A}\times\Conid{A}\mathbin{\char94 *}))}
\par Com este tipo simplesmente nos basta um passo para produzir o pretendido,
sendo que usamos a \ensuremath{\Varid{assocl}} estudada nas aulas.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pairsList}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},\Varid{a})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pairsList}\mathrel{=}\anaList{\Varid{g\char95 pairsList}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{center}
\fbox{\begin{minipage}{38em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g\char95 pairsList}\mathrel{=}(\Varid{id}+{}\<[24]%
\>[24]{}\Varid{assocl}\comp (\Varid{id}\times\conj{\Varid{head}}{\Varid{tail}}))\comp \Varid{outList}\comp \Varid{getEvenBlock}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}

Mais uma vez recorremos a um diagrama para compreender os genes pedidos
e os seus tipos. Para chegar à sua versão final tivemos de compreender
o \ensuremath{\Varid{conquer}}, que é um either, em que o lado esquerdo é a \ensuremath{\Varid{head}} de uma lista,
que tendo em conta o problema, será uma lista com uma \ensuremath{\Conid{MerkleTree}} singular.
Conhecendo o tipo da \ensuremath{\Varid{joinMerkleTree}} foi possivel
chegar ao tipo do lado direito do either, e assim obter o resto do diagrama.
\vspace{0.5cm}

\xymatrixcolsep{8pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
\mathbb{Z}^+\
		\ar[r]^-{\ensuremath{\Varid{divide}}}
		\ar[d]_-{\ensuremath{\anaList{\Varid{divide}}}}
&
FTree \mathbb{Z}\ \mathbb{Z} ^+\ +\ FTree \mathbb{Z}\ \mathbb{Z} ^+ \times\ \mathbb{Z}^+\
		\ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times\anaList{\Varid{divide}}}}
\\
	(FTree\ \mathbb{Z}\ \mathbb{Z} ^+)^+
		\ar[d]_-{\ensuremath{\cataNat{\Varid{conquer}}}}
		\ar@/^2pc/[r]^-{\ensuremath{\Varid{outNEList}}}
&
FTree \mathbb{Z}\ \mathbb{Z} ^+\ +\ FTree \mathbb{Z}\ \mathbb{Z} ^+\ \times (FTree\ \mathbb{Z}\ \mathbb{Z} ^+)^+
		\ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times\cataNat{\Varid{conquer}}}}
		\ar@/^2pc/[l]^-{\ensuremath{\Varid{inNEList}}}
\\
	FTree\ \mathbb{Z}\ \mathbb{Z}
&
    FTree\ \mathbb{Z}\ \mathbb{Z}^+ +\ FTree \mathbb{Z}\ \mathbb{Z}^+\ \times FTree\ \mathbb{Z}\ \mathbb{Z}
    \ar[l]^-{\ensuremath{\Varid{conquer}}}
}}

\vspace{0.5cm}
Distinto da primeira parte deste problema, em \ensuremath{{\FTree}\;\Varid{a}\;\Varid{c}}, \ensuremath{\Varid{c}} corresponde ao valor de hash de uma folha, da \ensuremath{\Conid{Unit}}, e o \ensuremath{\Varid{a}}
corresponde à concatenação dos filhos.
\par Para resolver estes genes tivemos de perceber em que fase do algoritmo estes se encontram.
Sendo que já temos a uma lista de pares a ser produzida, com a \ensuremath{\Varid{pairsList}}, resta-nos os passos 4 e 5 do algoritmo.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{classicMerkleTree}\mathbin{::}\Conid{Hashable}\;\Varid{a}\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to {\FTree}\;\mathbb{Z}\;\mathbb{Z}{}\<[E]%
\\
\>[B]{}\Varid{classicMerkleTree}\mathrel{=}(\Varid{hyloNEList}\;\Varid{conquer}\;\Varid{divide})\comp (\map \;\Varid{\Conid{Main}.hash}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Pelo diagrama anterior, concluimos que o divide irá juntar os passos 1 ao 4.
\par Sendo assim, o nosso objetivo seria, partindo de uma lista não vazia, criar no caso de uma lista singular, um \ensuremath{\Conid{Unit}}, correspondendo ao valor da
\ensuremath{\Conid{MerkleTree}\;\Conid{Root}}, e no caso de uma lista não singular, fazer os passos 3 e 4. Isto é, primeiro criar pares, com o auxilio da
anteriormente definida \ensuremath{\Varid{pairsList}}, de seguida criar uma lista de (sub)-\ensuremath{\Conid{MerkleTree}} definindo, para isto uma auxiliar \ensuremath{\Varid{concPair}}.
\par Tendo em conta o inicio do passo 5, caso a lista não seja singular, necessitamos de voltar ao passo 2 com a lista das cabeças como argumento.
Assim sendo, definimos a \ensuremath{\Varid{concPair}} e a \ensuremath{\Varid{concH}} que, partindo de uma lista de pares produzem uma lista de sub-àrvores e uma lista com as concatenações, respetivamente.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{89}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{divide}\mathrel{=}((\Varid{singl}\comp \Conid{Unit})+\conj{\Varid{concPair}}{\Varid{concH}}\comp (\Varid{pairsList}\comp \Varid{cons}))\comp \Varid{outNEList}\;{}\<[89]%
\>[89]{}\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{concPair}\mathrel{=}\cataList{\Varid{inList}\comp (\Varid{id}+\Varid{aux}\times\Varid{id})}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{aux}\;(\Varid{a},\Varid{b})\mathrel{=}\Conid{Comp}\;(\Varid{concHash}\;(\Varid{a},\Varid{b}))\;(\Conid{Unit}\;\Varid{a},\Conid{Unit}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{concH}\mathrel{=}\cataList{\Varid{inList}\comp (\Varid{id}+\Varid{concHash}\times\Varid{id})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\par O passo 5 e final do algoritmo, compõe a \ensuremath{\Conid{MerkleTree}}.
Para tal precisamos de definir o \ensuremath{\Varid{conquer}}.
Foi-nos já fornecida parte da definição deste, sendo que apenas tinhamos de definir o gene do catamorfismo de
\ensuremath{\Varid{mergeMerkleTree}}, que recebe uma \ensuremath{\Conid{MerkleTree}} e uma lista par.
\par No caso de receber um \ensuremath{\Conid{Unit}} e a lista, isto significa que que a list apenas terá um elemento, pelo que retornamos
a \ensuremath{\Varid{merkleTree}} dentro da lista, que tem como valor de hash o valor do \ensuremath{\Conid{Unit}} e as suas folhas.
\par O \ensuremath{h_2 } recebe o  tipo \ensuremath{(\Conid{Inteiro},(\Varid{f},\Varid{g}))\;\Varid{l}}, onde \ensuremath{\Varid{f}} e \ensuremath{\Varid{g}} são a \ensuremath{\Varid{mergeMerkleTree}} das folhas.
Chegando a esta conclusão, e analizando o resultado do \ensuremath{\Varid{anaNEList}\;\Varid{divide}}, percebemos que tinhamos de dividir a lista
recebida a meio e atribuir cada uma como argumento às folhas. Para dividir a lista em 2 definimos uma auxiliar \ensuremath{\Varid{splitHalf}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{conquer}\mathrel{=}{}\<[12]%
\>[12]{}\alt{\Varid{head}}{\Varid{joinMerkleTree}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{joinMerkleTree}\;(\Varid{l},\Varid{m})\mathrel{=}\Varid{mergeMerkleTree}\;\Varid{m}\;(\Varid{evenMerkleTreeList}\;\Varid{l}){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{mergeMerkleTree}\mathrel{=}\llparenthesis\, \alt{h_1 }{h_2 }\,\rrparenthesis{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}h_1 \;\Varid{c}\;\Varid{l}\mathrel{=}\Varid{head}\;\Varid{l}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}h_2 \;(\Varid{c},(\Varid{f},\Varid{g}))\;\Varid{l}\mathrel{=}\Conid{Comp}\;\Varid{c}\;(\Varid{f}\;(\p1\;(\Varid{splitHalf}\;\Varid{l})),\Varid{g}\;(\p2\;(\Varid{splitHalf}\;\Varid{l}))){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{splitHalf}\;\Varid{l}\mathrel{=}\Varid{splitAt}\;((\length \;\Varid{l})\mathbin{\Varid{`div`}}\mathrm{2})\;\Varid{l}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{evenMerkleTreeList}\mathrel{=}\Varid{getEvenBlock}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 2}

\par Para resolver este problema, resolvemos começar desenvolver o sistema resultante da aplicação
da lei de recursividade mútua, em que o \ensuremath{\Varid{f}} é o \ensuremath{\Varid{wc\char95 w}} e o g o \ensuremath{\Varid{lookahead\char95 sep}}

\begin{eqnarray*}
\start
  \ensuremath{\begin{lcbr}\Varid{wc\char95 w}\comp \mathsf{in}\mathrel{=}\Varid{h}\comp \fun F \;\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}}\\\Varid{lookahead\char95 sep}\comp \mathsf{in}\mathrel{=}\Varid{k}\comp \fun F \;\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}}\end{lcbr}}
%
\just\equiv{\textcolor{blue}{h=[h1,h2],\ k=[k1,k2],\ F-Lists,\ Absorsão-+\ (22),\ Natural-id\ (1)}}
%
\ensuremath{\begin{lcbr}\Varid{wc\char95 w}\comp \mathsf{in}\mathrel{=}[\mskip1.5mu h_1 ,h_2 \comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\mskip1.5mu]\\\Varid{lookahead\char95 sep}\comp \mathsf{in}\mathrel{=}[\mskip1.5mu k_1 ,k_2 \comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\mskip1.5mu]\end{lcbr}}
%
\just\equiv{\textcolor{blue}{inList,\ Fusão-+\ (20),\ Eq-+\ (27)}}
%
\ensuremath{\begin{lcbr}\Varid{wc\char95 w}\comp \Varid{nil}\mathrel{=}h_1 \\\Varid{wc\char95 w}\comp \Varid{cons}\mathrel{=}h_2 \comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\end{lcbr}}\\ & &
\ensuremath{\begin{lcbr}\Varid{lookahead\char95 sep}\comp \Varid{nil}\mathrel{=}k_1 \\\Varid{lookahead\char95 sep}\comp \Varid{cons}\mathrel{=}k_2 \comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\end{lcbr}}
%
\just\equiv{\textcolor{blue}{Pelas\ definições\ fornecidas\ podemos\ definirmo\ h\ e\ k}}
%
\ensuremath{\begin{lcbr}\Varid{wc\char95 w}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\mathrm{0}\\\Varid{wc\char95 w}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}(((\neg \comp \Varid{sp}\comp \p1)\mathrel{\wedge}(\p2\comp \p2))\to (\succ \comp \p1\comp \p2),(\p1\comp \p2))\comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\;(\Varid{c},\Varid{l})\end{lcbr}}\\ & &
\ensuremath{\begin{lcbr}\Varid{lookahead\char95 sep}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Conid{True}\\\Varid{lookahead\char95 sep}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}(\Varid{sp}\comp \p1)\comp (\Varid{id}\times\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}})\;(\Varid{c},\Varid{l})\end{lcbr}}
%
\just\equiv{\textcolor{blue}{Natural-p1\ (12)}}
%
\ensuremath{\begin{lcbr}\Varid{wc\char95 w}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\mathrm{0}\\\Varid{wc\char95 w}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}\mathbf{if}\;\neg \comp (\Varid{sep}\;\Varid{c})\mathrel{\wedge}\Varid{lookahead\char95 sep}\;\Varid{l}\;\mathbf{then}\;\Varid{wc\char95 w}\;\Varid{l}\mathbin{+}\mathrm{1}\;\mathbf{else}\;\Varid{wc\char95 w}\;\Varid{l}\end{lcbr}}\\ & &
\ensuremath{\begin{lcbr}\Varid{lookahead\char95 sep}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Conid{True}\\\Varid{lookahead\char95 sep}\;(\Varid{c}\mathbin{:}\Varid{l})\mathrel{=}\Varid{sp}\;\Varid{c}\end{lcbr}}
\end{eqnarray*}

\vspace{0.5cm}
Para definir o \ensuremath{h_2 }, uma vez que se trata de uma condicional, recorremos à
função pré-definiada \ensuremath{\Conid{Cond}}.
\par Na fórmula condicional \ensuremath{\Varid{p}\to \Varid{f},\Varid{g}} o nosso \ensuremath{\Varid{p}} será a condição \ensuremath{\Varid{sp}\;\Varid{c}\mathrel{\wedge}\Varid{lookahead\char95 sep}\;\Varid{l}}, o \ensuremath{\Varid{f}} é o caso da condição ser verdadeira,
\ensuremath{\Varid{wc\char95 w}\;\Varid{l}\mathbin{+}\mathrm{1}}, e o g, a a condição ser falsa \ensuremath{\Varid{wc\char95 w}\;\Varid{l}}. Como o \ensuremath{\Varid{p}} são duas condições utilizamos um split para obter um par \ensuremath{\Varid{sp}\;\Varid{c}} e \ensuremath{\Varid{lookahead\char95 sep}\;\Varid{l}}.
De seguida definimos uma auxiliar que recebe o resultado do split e retorna o valor da condição.
\par Para o definir o \ensuremath{\Varid{wc\char95 w\char95 final}}, tivemos de perceber a transformação \ensuremath{\Conid{Wrapper}\mathbin{/}\Conid{Worker}},
que, tal como sugere o nome, o \ensuremath{\Conid{Worker}} produz o resultado e o \ensuremath{\Conid{Wrapper}}, desse resultado, devolve o pretendido.
\par Percebendo isto, recorremos ao diagrama do caratmotfismo de listas do Worker.
\vspace{0.5cm}

\xymatrixcolsep{3pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
   Char^* \ar[d]_-{\ensuremath{\Varid{worker}}}
                \ar[rr]^-{\ensuremath{\Varid{outList}}} & \qquad
&  1\ +\ Char\ \times Char^*
  \ar[d]^{\ensuremath{\Varid{recList}\;\Varid{worker}}}
\\
    Int \times Bool &
&  1\ +\ Char\ \times (Int \times Bool)
    \ar[ll]^-{\ensuremath{[\mskip1.5mu \conj{\underline{\mathrm{0}}}{\Conid{True}},\conj{h_2 }{\Varid{sp}\comp \p1}\mskip1.5mu]}}
}}

\vspace{0.5cm}
Analisando o diagrama, e tendo em consideração os genes \ensuremath{\Varid{h}} e \ensuremath{\Varid{k}} já definidos, percebemos que o \ensuremath{\Conid{Worker}},
é o \ensuremath{\conj{\Varid{wc\char95 w}}{\Varid{lookahead\char95 sep}}}, ou seja pela aplicação da lei de recursividade mútua,
\ensuremath{\cataList{\conj{\Varid{h}}{\Varid{k}}}}, sendo o \ensuremath{\Varid{wc\char95 w\char95 final}} o primeiro valor do split produzirdo pelo \ensuremath{\Varid{worker}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{wc\char95 w\char95 final}\mathbin{::}[\mskip1.5mu \Conid{Char}\mskip1.5mu]\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{wc\char95 w\char95 final}\mathrel{=}\Varid{wrapper}\comp \Varid{worker}{}\<[E]%
\\
\>[B]{}\Varid{worker}\mathrel{=}\cataList{\alt{\Varid{g1}}{\Varid{g2}}}{}\<[E]%
\\
\>[B]{}\Varid{wrapper}\mathrel{=}\p1{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Gene de \ensuremath{\Varid{worker}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g1}\mathrel{=}\conj{h_1 }{k_1 }{}\<[E]%
\\
\>[B]{}\Varid{g2}\mathrel{=}\conj{h_2 }{k_2 }{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Genes \ensuremath{\Varid{h}\mathrel{=}\alt{h_1 }{h_2 }} e \ensuremath{\Varid{k}\mathrel{=}\alt{k_1 }{k_2 }} identificados no cálculo:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}h_1 \mathrel{=}\underline{\mathrm{0}}{}\<[E]%
\\
\>[B]{}h_2 \mathrel{=}\Varid{cond}\;(\Varid{testaCond}\comp \conj{\neg \comp \Varid{sp}\comp \p1}{\p2\comp \p2})\;(\succ \comp \p1\comp \p2)\;(\p1\comp \p2)\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{testaCond}\;(\Varid{c1},\Varid{c2})\mathrel{=}\Varid{c1}\mathrel{\wedge}\Varid{c2}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}k_1 \mathrel{=}\underline{\Conid{True}}{}\<[E]%
\\
\>[B]{}k_2 \mathrel{=}\Varid{sp}\comp \p1{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 3}

A primeira fase deste problema é definir os contrutores da biblioteca de uma \ensuremath{\Conid{XLeaf}}.
Primeiro tivemos de compreender o tipo \ensuremath{\Conid{X}}, para fazer o either \ensuremath{\Varid{inX}}.
\par Se o elemento da direita for um \ensuremath{\Varid{u}}, o X vai ser uma folha, ou seja \ensuremath{\Conid{XLeaf}\;\Varid{u}}.
No caso de ser do tipo \ensuremath{(\Varid{i},(\Conid{X}\;\Varid{u}\;\Varid{i},\Conid{X}\;\Varid{u}\;\Varid{i})} presisamos de fazer uncurry duas vezes após usar a auxiliar \ensuremath{\Varid{assocl}}:
\vspace{0.5cm}

\xymatrixcolsep{5pc}\xymatrixrowsep{3pc}
\centerline{\xymatrix{
   (i, (X u i, X u i) \ar[rr]^-{\ensuremath{\Varid{assocl}}} && ((i,X u i),X u i) \ar[rr]^-{\ensuremath{\uncurry{\uncurry{\Conid{Node}}}}} && X u i
}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inX}\mathbin{::}\Varid{u}+(\Varid{i},(\Conid{X}\;\Varid{u}\;\Varid{i},\Conid{X}\;\Varid{u}\;\Varid{i}))\to \Conid{X}\;\Varid{u}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{inX}\mathrel{=}\alt{\Conid{XLeaf}}{\uncurry{\uncurry{\Conid{Node}}}\comp \Varid{assocl}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{outX}\;(\Conid{XLeaf}\;\Varid{u})\mathrel{=}i_1\;\Varid{u}{}\<[E]%
\\
\>[B]{}\Varid{outX}\;(\Conid{Node}\;\Varid{i}\;\Varid{l}\;\Varid{r})\mathrel{=}i_2\;(\Varid{i},(\Varid{l},\Varid{r})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{baseX}\;\Varid{f}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{f}+(\Varid{h}{}\<[25]%
\>[25]{}\times(\Varid{g}\times\Varid{g})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recX}\;\Varid{f}\mathrel{=}\Varid{baseX}\;\Varid{id}\;\Varid{id}\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataX}\;\Varid{g}\mathrel{=}\Varid{g}\comp (\Varid{recX}\;(\Varid{cataX}\;\Varid{g}))\comp \Varid{outX}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaX}\;\Varid{f}\mathrel{=}\Varid{inX}\comp (\Varid{recX}\;(\Varid{anaX}\;\Varid{f}))\comp \Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloX}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{cataX}\;\Varid{f}\comp \Varid{anaX}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\vspace{0.5cm}
De seguida foi preciso atualizara biblioteca anterior para uma outra que permita partições n-árias.
\vspace{0.3cm}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Xn}\;\Varid{u}\;\Varid{i}\mathrel{=}\Conid{XLeafn}\;\Varid{u}\mid \Conid{Noden}\;\Varid{i}\;[\mskip1.5mu \Conid{Xn}\;\Varid{u}\;\Varid{i}\mskip1.5mu]\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{inXn}\mathbin{::}\Varid{u}+(\Varid{i},[\mskip1.5mu \Conid{Xn}\;\Varid{u}\;\Varid{i}\mskip1.5mu])\to \Conid{Xn}\;\Varid{u}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{inXn}\mathrel{=}\alt{\Conid{XLeafn}}{\uncurry{\Conid{Noden}}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{outXn}\;(\Conid{XLeafn}\;\Varid{u})\mathrel{=}i_1\;\Varid{u}{}\<[E]%
\\
\>[B]{}\Varid{outXn}\;(\Conid{Noden}\;\Varid{i}\;\Varid{l})\mathrel{=}i_2\;(\Varid{i},\Varid{l}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{baseXn}\;\Varid{f}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{f}+(\Varid{h}{}\<[26]%
\>[26]{}\times\map \;\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recXn}\;\Varid{f}\mathrel{=}\Varid{baseXn}\;\Varid{id}\;\Varid{id}\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataXn}\;\Varid{g}\mathrel{=}\Varid{g}\comp \Varid{recXn}\;(\Varid{cataXn}\;\Varid{g})\comp \Varid{outXn}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaXn}\;\Varid{f}\mathrel{=}\Varid{inXn}\comp (\Varid{recXn}\;(\Varid{anaXn}\;\Varid{f}))\comp \Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloXn}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{cataXn}\;\Varid{f}\comp \Varid{anaXn}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection*{Problema 4}
\vspace{0.3cm}
\subsubsection*{PairL}
\par Sendo o \ensuremath{\Varid{pairL}} um anamorfismo de listas, podemos representa-lo pelo diagrama abaixo.
\vspace{0.5cm}

\xymatrixcolsep{6pc}\xymatrixrowsep{5pc}
\centerline{\xymatrix{
   A^*\ \ar[d]_-{\ensuremath{\Varid{pairL}}}
   \ar[rr]^-{\ensuremath{(\Varid{id}\mathbin{+}\Varid{assocl}\comp (\Varid{id}\times\conj{\Varid{head}}{\Varid{id}}))\comp \Varid{outNEList}}} & \qquad
&    A + ((A,A) \times A^*)  \ar[d]^{\ensuremath{\Varid{recList}\;\Varid{pairL}}}
\\
    (A,A)^* &
     &  A + ((A,A) \times (A,A)^*) \ar[ll]^-{\ensuremath{\Varid{inList}}}
}}

\vspace{0.5cm}

\par Para obter a solução, utilizamos o \ensuremath{\Varid{outNEList}}. Sendo que o lado esquerdo será o elemento único que irá ser ignorado,
uma vez que o problema se aplica a listas de tamanho maior que 1,
No lado direito, aplicamos um split para por no tipo \ensuremath{\Conid{A}\times(\Conid{A}\times\Conid{A}\mathbin{*})}, em que o segundo \ensuremath{\Conid{A}} é a \ensuremath{\Varid{head}} da \ensuremath{\Varid{tail}} da lista original,
e a lista é essa mesma \ensuremath{\Varid{tail}}. Após ter este tipo utilizamos a \ensuremath{\Varid{assocl}} para produzir o resultado pretendido.
\vspace{0.5cm}

\begin{center}
\fbox{\begin{minipage}{27em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pairL}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},\Varid{a})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pairL}\mathrel{=}\anaList{\Varid{g}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{g}\mathrel{=}(\Varid{id}+\Varid{assocl}\comp (\Varid{id}\times\conj{\Varid{head}}{\Varid{id}}))\comp \Varid{outNEList}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}

\subsubsection*{markMap}
\par Para conseguir chegar ao resutado de \ensuremath{f_2 } precisamos de perceber o que um mapa representa e como modificá-lo.
A primiera conclusão a que chegamos, analisando o exemplo apresentado no problema 4 do Capitulo 1, foi que a posição (0,0) é a última à esquerda, posição (0,1) a acima dessa, e a posição (1,0) a da direita do mapa.
Ou seja uma posição é do tipo (coluna,linha).
\par De seguida, pela análise dos mapas fornecidos, percebemos que, na matriz, o primeiro elemento diz respeito à linha inferior do mapa, a segunda a linha a cima e assim adiante.
\par resolvemos desenvolver o catamorfismo pela aplicação da \ensuremath{\Conid{Lei}\;\Conid{Universal}\;\Varid{dos}\;\Conid{Catamorfismos}}:
\begin{eqnarray*}
\start
  \ensuremath{\Varid{markMap}\;\Varid{l}\mathrel{=}\cata{[\mskip1.5mu \underline{\Varid{id}},f_2 \mskip1.5mu]}\;(\Varid{pairL}\;\Varid{l})}
%
\just\equiv{\textcolor{blue}{Universal-cata\ (45)}}
%
  \ensuremath{\Varid{markMap}\comp \Varid{inList}\;\Varid{l}\mathrel{=}[\mskip1.5mu \underline{\Varid{id}},f_2 \mskip1.5mu]\comp \Conid{F}\;\Varid{markMap}\;(\Varid{pairL}\;\Varid{l})}
%
\just\equiv{\textcolor{blue}{inList,\ F\ markMap,\ Fusão-+\ (20),\ Absorção-+\ (22),\ Eq-+\ (27)}}
%
      \ensuremath{\begin{lcbr}\Varid{markMap}\comp \Varid{nil}\;\Varid{l}\mathrel{=}\underline{\Varid{id}}\\\Varid{markMap}\comp \Varid{cons}\;\Varid{l}\mathrel{=}f_2 \comp (\Varid{id}\times\Varid{markMap})\;(\Varid{pairL}\;\Varid{l})\end{lcbr}}
%
\just\equiv{\textcolor{blue}{nil,\ cons}}
%
      \ensuremath{\begin{lcbr}\Varid{markMap}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]\\\Varid{markMap}\;(\Varid{pt1}\mathbin{:}\Varid{pt2}\mathbin{:}\Varid{t})\mathrel{=}f_2 \comp (\Varid{id}\times\Varid{markMap})\;((\Varid{pt1},\Varid{pt2}),\Varid{t})\end{lcbr}}
%
\just\equiv{\textcolor{blue}{f2}}
%
      \ensuremath{\begin{lcbr}\Varid{markMap}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]\\\Varid{markMap}\;(\Varid{pt1}\mathbin{:}\Varid{pt2}\mathbin{:}\Varid{t})\mathrel{=}\Varid{aux}\comp (\Varid{substMatriz}\comp \conj{\uncurry{\Varid{toCell}}}{\p1}\;(\Varid{pt1},\Varid{pt2})\times\Varid{markMap}\;\Varid{t})\end{lcbr}}
%
\just\equiv{\textcolor{blue}{}}
%
      \ensuremath{\begin{lcbr}\Varid{markMap}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]\\\Varid{markMap}\;(\Varid{pt1}\mathbin{:}\Varid{pt2}\mathbin{:}\Varid{t})\mathrel{=}(\Varid{substMatriz}\comp \conj{\uncurry{\Varid{toCell}}\;(\Varid{pt1},\Varid{pt2})}{\Varid{pt1}})\comp \Varid{markMap}\;\Varid{t}\end{lcbr}}
\end{eqnarray*}
\par Assim conseguimos definir o \ensuremath{\Conid{MarkMap}} utilizando a auxiliar fornecida \ensuremath{\Varid{subst}} e a \ensuremath{\Varid{toCell}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{markMap}\mathbin{::}[\mskip1.5mu \Conid{Pos}\mskip1.5mu]\to \Conid{Map}\to \Conid{Map}{}\<[E]%
\\
\>[B]{}\Varid{markMap}\;\Varid{l}\mathrel{=}\cataList{\alt{\underline{\Varid{id}}}{f_2 }}\;(\Varid{pairL}\;\Varid{l})\;\mathbf{where}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{center}
\fbox{\begin{minipage}{30em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}f_2 \mathrel{=}\Varid{aux}\comp (\Varid{substMatriz}\comp \conj{\uncurry{\Varid{toCell}}}{\p1}\times\Varid{id}){}\<[E]%
\\
\>[3]{}\Varid{substMatriz}\;(\Varid{c},(\Varid{x},\Varid{y}))\;\Varid{m}\mathrel{=}\Varid{subst}\;(\Varid{subst}\;\Varid{c}\;\Varid{x}\;(\Varid{m}\mathbin{!!}\Varid{y}))\;\Varid{y}\;\Varid{m}{}\<[E]%
\\
\>[3]{}\Varid{aux}\;(\Varid{f},\Varid{g})\mathrel{=}\Varid{f}\comp \Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}
\vspace{0.5cm}
Neste momento é nos pedido para definir \ensuremath{\Varid{scout}}, que é um catamorfismo natural,
cujo gene é um either composto por \ensuremath{f_1 } e o \ensuremath{\Varid{bind}} de \ensuremath{f_2 \;\Varid{m}\;\Varid{s}}
\par Primeiramente usamos a auxuliar \ensuremath{\Varid{checkAround}} que nos retorna uma lista com as posições válidas,
em seguida...
\vspace{0.5cm}
\begin{center}
\fbox{\begin{minipage}{25em}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{scout}\mathbin{::}\Conid{Map}\to \Conid{Pos}\to \Conid{Pos}\to \Conid{Int}\to [\mskip1.5mu [\mskip1.5mu \Conid{Pos}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{scout}\;\Varid{m}\;\Varid{s}\;\Varid{t}\mathrel{=}\cataNat{\alt{f_1 }{(\bind f_2 \;\Varid{m}\;\Varid{s})}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_1 \mathrel{=}{}\<[9]%
\>[9]{}\Varid{singl}\comp \Varid{singl}\comp \underline{\Varid{s}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}f_2 \mathrel{=}\bot \mbox{\onelinecomment  checkAround}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}}
\end{center}
\vspace{0.5cm}
\paragraph{Valorização}
\par Completar as seguintes funções de teste no \QuickCheck\ para verificação de propriedades das funções pedidas, a saber:

\begin{propriedade}
A lista correspondente ao lado esquerdo
dos pares em (\ensuremath{\Varid{pairL}\;\Varid{l}}) é a lista original \ensuremath{\Varid{l}} a menos do último elemento.
Analogamente, a lista correspondente ao lado direito
dos pares em (\ensuremath{\Varid{pairL}\;\Varid{l}}) é a lista original \ensuremath{\Varid{l}} a menos do primeiro elemento:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 reconst}\;\Varid{l}\mathrel{=}(\map \;\p1\;(\Varid{pairL}\;\Varid{l})\equiv (\Varid{init}\;\Varid{l}))\mathrel{\wedge}((\map \;\p2\;(\Varid{pairL}\;\Varid{l}))\equiv (\Varid{tail}\;\Varid{l})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\begin{propriedade}
Assuma que uma linha (de um mapa) é prefixa de uma outra linha. Então a representação
da primeira linha também prefixa a representação da segunda linha:
\end{propriedade}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 prefix2}\;\Varid{l}\;\Varid{l'}\mathrel{=}\Varid{prefixes}\;\Varid{l}\equiv \Varid{l'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{propriedade}
Para qualquer linha (de um mapa), a sua representação deve conter um número de símbolos correspondentes a
um tipo célula igual ao número de vezes que esse tipo de célula aparece na linha em questão.
\end{propriedade}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 nmbrs}\;\Varid{l}\;\Varid{c}\mathrel{=}\Varid{count}\;(\Varid{fromCell}\;(\Varid{head}\;\Varid{l}))\;\Varid{c}\equiv \Varid{count}\;(\Varid{head}\;\Varid{c})\;\Varid{c}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{count}\mathbin{::}(\Conid{Eq}\;\Varid{a})\Rightarrow \Varid{a}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{count}\mathrel{=}\Varid{aux}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{aux}\;\Varid{x}\mathrel{=}\length \comp \Varid{filter}\;(\equiv \Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{propriedade}
Para qualquer lista \ensuremath{\Varid{l}} a função \ensuremath{\Varid{markMap}\;\Varid{l}} é idempotente.
\end{propriedade}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{64}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inBounds}\;\Varid{m}\;(\Varid{x},\Varid{y})\mathrel{=}(\Varid{nlines}\;\Varid{m})\geq \Varid{x}\mathrel{\wedge}(\Varid{ncols}\;\Varid{m})\geq \Varid{y}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{prop\char95 idemp2}\;\Varid{l}\;\Varid{m}\mathrel{=}\Varid{isValidMap}\;\Varid{m}\mathrel{\wedge}\Varid{isValidMap}\;(\Varid{markMap}\;\Varid{l}\;\Varid{m})\mathrel{\wedge}{}\<[64]%
\>[64]{}(\Varid{and}\;(\map \;(\Varid{inBounds}\;\Varid{m})\;\Varid{l})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{\wedge}(\Varid{ncols}\;\Varid{m})\equiv (\Varid{ncols}\;(\Varid{markMap}\;\Varid{l}\;\Varid{m})){}\<[42]%
\>[42]{}\mathrel{\wedge}(\Varid{nlines}\;\Varid{m})\equiv (\Varid{nlines}\;(\Varid{markMap}\;\Varid{l}\;\Varid{m})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{propriedade}
Todas as posições presentes na lista dada como argumento irão fazer com que
as células correspondentes no mapa deixem de ser \ensuremath{\Conid{Free}}.
\end{propriedade}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 extr2}\;\Varid{l}\;\Varid{m}\mathrel{=}((\Varid{m}\mathbin{!!}(\p1\;(\Varid{head}\;\Varid{l})))\mathbin{!!}(\p2\;(\Varid{head}\;\Varid{l}))\not\equiv \Conid{Free})\mathbin{:}\Varid{prop\char95 extr2}\;(\Varid{tail}\;\Varid{l})\;\Varid{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{propriedade}
Quanto maior for o tamanho máximo dos caminhos mais caminhos que alcançam a
posição alvo iremos encontrar:
\end{propriedade}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 reach}\;\Varid{m}\;\Varid{t}\;\Varid{n}\;\Varid{n'}\mathrel{=}(\Varid{n}\mathbin{>}\Varid{n'})\mathrel{\wedge}(\length \;(\Varid{scout}\;\Varid{m}\;(\mathrm{0},\mathrm{0})\;\Varid{t}\;\Varid{n})\mathbin{>}\length \;(\Varid{scout}\;\Varid{m}\;(\mathrm{0},\mathrm{0})\;\Varid{t}\;\Varid{n'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


%----------------- Índice remissivo (exige makeindex) -------------------------%

\printindex

%----------------- Bibliografia (exige bibtex) --------------------------------%

\bibliographystyle{plain}
\bibliography{cp2122t}

%----------------- Fim do documento -------------------------------------------%
\end{document}
